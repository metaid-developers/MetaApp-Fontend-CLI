<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MetaAPP</title>

    <!-- Tailwind CSS -->

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <!-- Vue 3 ÂíåÁõ∏ÂÖ≥Â∫ì -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/vue-demi@0.14.10/lib/index.iife.js"></script>
    <script src="https://unpkg.com/pinia@2.1.7/dist/pinia.iife.js"></script>
    <script src="https://unpkg.com/@vueuse/shared@10.7.2/index.iife.min.js"></script>
    <script src="https://unpkg.com/@vueuse/core@10.7.2/index.iife.min.js"></script>

    <!-- Â∑•ÂÖ∑Â∫ì -->
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/metaidjs-v2@1.0.0/dist/metaid.umd.js"></script>
    <!-- Buffer ÊµèËßàÂô®ÁâàÊú¨ -->
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm"></script>
    <script>
        // Á°Æ‰øù Buffer ÂÖ®Â±ÄÂèØÁî®
        if (typeof buffer !== 'undefined' && buffer.Buffer) {
            window.Buffer = buffer.Buffer;
        }
    </script>

    <style>
        /* Ëá™ÂÆö‰πâÊ†∑Âºè */
        .modal-backdrop {
            background: rgba(0, 0, 0, 0.5);
        }

        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s;
        }

        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }

        .scale-enter-active, .scale-leave-active {
            transition: all 0.3s;
        }

        .scale-enter-from, .scale-leave-to {
            opacity: 0;
            transform: scale(0.95);
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Áî®Êà∑Â§¥ÂÉèÊ†∑Âºè */
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* ÊåâÈíÆÊ†∑Âºè - Êõø‰ª£ DaisyUI btn Á±ª */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            font-weight: 500;
            border-radius: 0.5rem;
            transition-property: color, background-color, border-color;
            transition-duration: 200ms;
            border: 1px solid #d1d5db;
            background-color: #ffffff;
            color: #374151;
        }

        .btn:hover {
            background-color: #f9fafb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #2563eb;
            color: #ffffff;
            border-color: #2563eb;
        }

        .btn-primary:hover {
            background-color: #1d4ed8;
        }

        .btn-secondary {
            background-color: #9333ea;
            color: #ffffff;
            border-color: #9333ea;
        }

        .btn-secondary:hover {
            background-color: #7e22ce;
        }

        .btn-success {
            background-color: #16a34a;
            color: #ffffff;
            border-color: #16a34a;
        }

        .btn-success:hover {
            background-color: #15803d;
        }

        .btn-error {
            background-color: #dc2626;
            color: #ffffff;
            border-color: #dc2626;
        }

        .btn-error:hover {
            background-color: #b91c1c;
        }

        .btn-warning {
            background-color: #eab308;
            color: #ffffff;
            border-color: #eab308;
        }

        .btn-warning:hover {
            background-color: #ca8a04;
        }

        .btn-info {
            background-color: #3b82f6;
            color: #ffffff;
            border-color: #3b82f6;
        }

        .btn-info:hover {
            background-color: #2563eb;
        }

        .btn-outline {
            background-color: transparent;
            border: 2px solid currentColor;
        }

        .btn-outline:hover {
            background-color: gray;
            color: #ffffff;
        }

        .btn-sm {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
        }

        .btn-circle {
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            padding: 0;
        }

        .btn-ghost {
            border-color: transparent;
            background-color: transparent;
        }

        .btn-ghost:hover {
            background-color: #f3f4f6;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Ê®°ÊÄÅÊ°ÜÊ†∑Âºè - Êõø‰ª£ DaisyUI modal Á±ª */
        .modal {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-open {
            display: flex;
        }

        .modal::before {
            content: '';
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-box {
            position: relative;
            background-color: #ffffff;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            max-width: 32rem;
            width: 100%;
            margin-left: 1rem;
            margin-right: 1rem;
            z-index: 10;
        }

        .modal-action {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        /* ÊèêÁ§∫Ê°ÜÊ†∑Âºè - Êõø‰ª£ DaisyUI alert Á±ª */
        .alert {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border-radius: 0.5rem;
            border-width: 1px;
        }

        .alert-success {
            background-color: #f0fdf4;
            color: #166534;
            border-color: #bbf7d0;
        }

        .alert-error {
            background-color: #fef2f2;
            color: #991b1b;
            border-color: #fecaca;
        }

        .alert-warning {
            background-color: #fefce8;
            color: #854d0e;
            border-color: #fef08a;
        }

        .alert-info {
            background-color: #eff6ff;
            color: #1e40af;
            border-color: #bfdbfe;
        }

        /* Ë°®ÂçïÊéß‰ª∂ - Êõø‰ª£ DaisyUI form-control Á±ª */
        .form-control {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* ËæìÂÖ•Ê°ÜÊ†∑Âºè - Êõø‰ª£ DaisyUI input Á±ª */
        .input {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition-property: color, background-color, border-color;
            transition-duration: 200ms;
        }

        .input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .input-bordered {
            border: 1px solid #d1d5db;
            background-color: #ffffff;
        }

        .input-sm {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
        }

        /* Textarea Ê†∑Âºè - Êõø‰ª£ DaisyUI textarea Á±ª */
        .textarea {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition-property: color, background-color, border-color;
            transition-duration: 200ms;
            min-height: 100px;
            resize: vertical;
        }

        .textarea:focus {
            outline: none;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .textarea-bordered {
            border: 1px solid #d1d5db;
            background-color: #ffffff;
        }

        /* Select ‰∏ãÊãâÈÄâÊã©Ê°ÜÊ†∑Âºè - Êõø‰ª£ DaisyUI select Á±ª */
        .select {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition-property: color, background-color, border-color;
            transition-duration: 200ms;
            appearance: none;
            background-repeat: no-repeat;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        .select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .select-bordered {
            border: 1px solid #d1d5db;
            background-color: #ffffff;
        }

        /* ÂØºËà™Ê†è - Êõø‰ª£ DaisyUI navbar Á±ª */
        .navbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
        }

        /* Âç°ÁâáÊ†∑Âºè - Êõø‰ª£ DaisyUI card Á±ª */
        .card {
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .card-body {
            padding: 1.5rem;
        }

        .card-title {
            font-size: 1.25rem;
            line-height: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .card-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* ‰∏ãÊãâËèúÂçï - Êõø‰ª£ DaisyUI dropdown Á±ª */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-end {
            text-align: right;
        }

        .dropdown-content {
            position: absolute;
            right: 0;
            margin-top: 0.5rem;
            transform-origin: top right;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
            display: none;
        }

        .dropdown:hover .dropdown-content,
        .dropdown:focus-within .dropdown-content {
            display: block;
        }

        .menu {
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
        }

        .menu li {
            list-style: none;
        }

        .menu a {
            display: block;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #374151;
            transition-property: color, background-color;
            transition-duration: 200ms;
        }

        .menu a:hover {
            background-color: #f3f4f6;
        }

        /* Âä†ËΩΩÂä®Áîª - Êõø‰ª£ DaisyUI loading Á±ª */
        .loading {
            display: inline-block;
        }

        .loading-spinner {
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid currentColor;
            border-top-color: transparent;
            border-radius: 9999px;
            animation: spin 1s linear infinite;
        }

        /* ‰∏ªÈ¢òÈ¢úËâ≤ÂèòÈáè - Êõø‰ª£ DaisyUI base È¢úËâ≤ */
        .bg-base-100 {
            background-color: #ffffff;
        }

        .bg-base-200 {
            background-color: #f9fafb;
        }

        .bg-base-300 {
            background-color: #f3f4f6;
        }

        .text-base-content {
            color: #111827;
        }

        /* Êñá‰ª∂ËæìÂÖ•Ê°Ü */
        .file-input {
            width: 100%;
        }

        .file-input-bordered {
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            background-color: #ffffff;
        }

        .file-input-bordered::file-selector-button {
            margin-right: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: 0;
            background-color: #eff6ff;
            color: #1d4ed8;
            font-weight: 500;
            cursor: pointer;
        }

        .file-input-bordered:hover::file-selector-button {
            background-color: #dbeafe;
        }

        /* ÂúÜËßíÁõíÂ≠ê */
        .rounded-box {
            border-radius: 0.5rem;
        }

        /* ÂàÜÈöîÁ∫ø */
        .divider {
            border-top: 1px solid #e5e7eb;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        /* Toast ÈÄöÁü•Ê°ÜÊ†∑Âºè - Êõø‰ª£ DaisyUI toast Á±ª */
        .toast {
            position: fixed;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            pointer-events: none;
        }

        .toast-top {
            top: 0;
        }

        .toast-bottom {
            bottom: 0;
        }

        .toast-start {
            left: 0;
        }

        .toast-end {
            right: 0;
        }

        .toast-center {
            left: 50%;
            transform: translateX(-50%);
        }

        .toast-middle {
            top: 50%;
            transform: translateY(-50%);
        }

        .toast > * {
            pointer-events: auto;
        }

        /* Badge ÂæΩÁ´†Ê†∑Âºè - Êõø‰ª£ DaisyUI badge Á±ª */
        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            line-height: 1rem;
            font-weight: 600;
            border-radius: 9999px;
            background-color: #f3f4f6;
            color: #1f2937;
        }

        .badge-primary {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .badge-secondary {
            background-color: #f3e8ff;
            color: #6b21a8;
        }

        .badge-success {
            background-color: #dcfce7;
            color: #166534;
        }

        .badge-warning {
            background-color: #fef3c7;
            color: #854d0e;
        }

        .badge-error {
            background-color: #fee2e2;
            color: #991b1b;
        }

        .badge-info {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .badge-sm {
            padding: 0.125rem 0.375rem;
            font-size: 0.75rem;
            line-height: 1rem;
        }

        .badge-lg {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
        }

        /* Â§¥ÂÉèÂÆπÂô® */
        .avatar {
            display: inline-block;
            position: relative;
        }

        .avatar > div {
            overflow: hidden;
            border-radius: 9999px;
        }

        /* Ê†áÁ≠æ */
        .label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }

        .label-text {
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #374151;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ==================== Êñá‰ª∂‰∏ä‰º†ÁªÑ‰ª∂Ê†∑Âºè ==================== */
        .file-drop-zone {
            border: 2px dashed #d1d5db;
            border-radius: 0.5rem;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #f9fafb;
        }

        .file-drop-zone:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .file-drop-zone.drag-over {
            border-color: #2563eb;
            background-color: #dbeafe;
            transform: scale(1.02);
        }

        .file-preview-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: #f9fafb;
        }

        .file-preview-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }

        .file-preview-item:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .file-preview-content {
            flex-shrink: 0;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f3f4f6;
            border-radius: 0.375rem;
            overflow: hidden;
        }

        .file-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-icon-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-icon {
            width: 32px;
            height: 32px;
        }

        .file-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .file-name {
            font-size: 0.875rem;
            font-weight: 500;
            color: #111827;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .file-remove-btn {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ef4444;
            background-color: #fef2f2;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-remove-btn:hover {
            background-color: #fee2e2;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script type="module">
        // Á≠âÂæÖÊâÄÊúâÂ∫ìÂä†ËΩΩÂÆåÊàê
        window.addEventListener('load', () => {
            console.log('All libraries loaded, checking...');
            console.log('Vue:', typeof Vue !== 'undefined' ? '‚úì' : '‚úó');
            console.log('Pinia:', typeof Pinia !== 'undefined' ? '‚úì' : '‚úó');
            console.log('VueUse:', typeof VueUse !== 'undefined' ? '‚úì' : '‚úó');
            console.log('Buffer:', typeof Buffer !== 'undefined' ? '‚úì' : '‚úó');
             console.log('MetaIDJs:', typeof MetaIDJs !== 'undefined' ? '‚úì' : '‚úó');
              // MetaIDJs Áé∞Âú®ÂèØ‰ª•‰Ωú‰∏∫ÂÖ®Â±ÄÂØπË±°‰ΩøÁî®
       
        });

        // Ê£ÄÊü•ÂøÖË¶ÅÁöÑÂÖ®Â±ÄÂèòÈáè
        if (typeof Vue === 'undefined') {
            throw new Error('Vue is not loaded');
        }
        if (typeof Pinia === 'undefined') {
            throw new Error('Pinia is not loaded');
        }
        if (typeof VueUse === 'undefined') {
            console.warn('VueUse is not loaded - will use fallback implementation');
        }
        if (typeof Buffer === 'undefined') {
            console.warn('Buffer is not loaded - Buffer operations will be limited');
            // Êèê‰æõÁÆÄÂçïÁöÑ Buffer ÈôçÁ∫ßÂÆûÁé∞
            window.Buffer = {
                from: (data, encoding) => {
                    if (encoding === 'hex') {
                        // Â∞Ü hex Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Â≠óËäÇÊï∞ÁªÑ
                        const bytes = [];
                        for (let i = 0; i < data.length; i += 2) {
                            bytes.push(parseInt(data.substr(i, 2), 16));
                        }
                        return {
                            toString: (toEncoding) => {
                                if (toEncoding === 'base64') {
                                    // ÁÆÄÂçïÁöÑ base64 ÁºñÁ†Å
                                    return btoa(String.fromCharCode.apply(null, bytes));
                                }
                                return data;
                            }
                        };
                    }
                    return { toString: () => data };
                }
            };
        }

        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
        const { defineStore, createPinia } = Pinia;

        // ==================== Meta-Contract Ëß£ÊûÑ ====================
        // ‰ªéÂÖ®Â±Ä MetaIDJs ÂØπË±°‰∏≠Ëé∑Âèñ TxComposer Âíå mvc
        let TxComposer, mvc;

        // Á≠âÂæÖ MetaIDJs Âä†ËΩΩÂÆåÊàê
        function waitForMetaIDJs() {
            return new Promise((resolve) => {
                if (typeof MetaIDJs !== 'undefined') {
                    TxComposer = MetaIDJs.TxComposer;
                    mvc = MetaIDJs.mvc;
                    resolve();
                } else {
                    const checkInterval = setInterval(() => {
                        if (typeof MetaIDJs !== 'undefined') {
                            TxComposer = MetaIDJs.TxComposer;
                            mvc = MetaIDJs.mvc;
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                }
            });
        }

        // VueUse Core - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂÖ®Â±ÄÂèòÈáèÂêçÔºåÂ¶ÇÊûúÂ§±Ë¥•Âàô‰ΩøÁî®ÈôçÁ∫ßÂÆûÁé∞
        let useLocalStorage, createGlobalState;

        if (typeof VueUse !== 'undefined') {
            ({ useLocalStorage, createGlobalState } = VueUse);
        } else {
            // ÈôçÁ∫ßÂÆûÁé∞ÔºöËá™Â∑±ÂÆûÁé∞ useLocalStorage Âíå createGlobalState
            console.warn('VueUse not found, using fallback implementation');

            useLocalStorage = (key, initialValue) => {
                const data = ref(initialValue);

                // ‰ªé localStorage ËØªÂèñÂàùÂßãÂÄº
                try {
                    const item = localStorage.getItem(key);
                    if (item !== null) {
                        data.value = JSON.parse(item);
                    }
                } catch (error) {
                    console.error('Error reading from localStorage:', error);
                }

                // ÁõëÂê¨ÂèòÂåñÂπ∂‰øùÂ≠òÂà∞ localStorage
                watch(data, (newValue) => {
                    try {
                        localStorage.setItem(key, JSON.stringify(newValue));
                    } catch (error) {
                        console.error('Error writing to localStorage:', error);
                    }
                }, { deep: true });

                return data;
            };

            createGlobalState = (stateFactory) => {
                let state;
                return () => {
                    if (!state) {
                        state = stateFactory();
                    }
                    return state;
                };
            };
        }

        // ==================== Â∏∏ÈáèÂÆö‰πâ ====================
        const CONSTANTS = {
            NETWORK: 'livenet',
            SIGNING_MESSAGE: 'IDNote Authentication',
            MAN_PUB_KEY: '048add0a6298f10a97785f7dd069eedb83d279a6f03e73deec0549e7d6fcaac4eef2c279cf7608be907a73c89eb44c28db084c27b588f1bd869321a6f104ec642d',
            MAN_BASE_URL: 'https://man.metaid.io',
            MAN_V2_BASE_URL:'https://manapi.metaid.io',
            BTC_FEE_RATE_URL: 'https://api.mvcscan.com/browser/v1/fees/recommended?chain=btc',
            MVC_FEE_RATE_URL: 'https://api.mvcscan.com/browser/v1/fees/recommended?net=livenet',
            METAFS_API_BASE:`https://file.metaid.io/metafile-uploader`,
            METASO_ASSET_API:`https://www.metaso.network/assist-open-api`,
            BroadCast_API:`https://www.metalet.space/wallet-api/v3/tx/broadcast`
        };

        // ==================== Toast/Alert Â∑•ÂÖ∑ ====================
        // ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑtoastÁ≥ªÁªü‰ΩøÁî®Ëá™ÂÆö‰πâÁöÑalertÊ†∑Âºè
        const useToast = createGlobalState(() => {
            const alerts = ref([]);
            let alertId = 0;

            const showToast = (message, type = 'info') => {
                const id = alertId++;
                alerts.value.push({ id, message, type });
                setTimeout(() => {
                    alerts.value = alerts.value.filter(a => a.id !== id);
                }, 3000);
            };

            return { alerts, showToast };
        });

        // ==================== Â∑•ÂÖ∑ÂáΩÊï∞ ====================
        // Âª∂ËøüÂáΩÊï∞
        function sleep(timer = 2000) {
            return new Promise(resolve => setTimeout(resolve, timer));
        }

        // ÂÆåÊï¥ÈáçÊñ∞Âä†ËΩΩÈ°µÈù¢
        function completeReload() {
            const url = new URL(window.location.href);
            url.searchParams.delete('clear');
            url.searchParams.delete('address');
            window.location.href = url.href;
        }

        // ==================== HTTP ËØ∑Ê±ÇÂ∑•ÂÖ∑ (‰ΩøÁî® Fetch ÊõøÊç¢ Axios) ====================
        // ÂàõÂª∫HTTPËØ∑Ê±ÇÁ±ª
        class HttpRequest {
            constructor(baseURL, config = {}) {
                this.baseURL = baseURL;
                this.config = config;
            }

            getToken() {
                return localStorage.getItem('metaid_access_token');
            }

            async request(url, options = {}) {
                const token = this.getToken();
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers,
                };

                if (token) {
                    headers.Authorization = `Bearer ${token}`;
                }

                try {
                    console.log(`üì§ [${options.method || 'GET'}] ${url}`);

                    const response = await fetch(this.baseURL + url, {
                        ...options,
                        headers,
                    });

                    console.log(`üì• [${options.method || 'GET'}] ${url} - Status: ${response.status}`);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();

                    // Ëá™ÂÆö‰πâÂìçÂ∫îÂ§ÑÁêÜ
                    if (this.config.responseHandler) {
                        return this.config.responseHandler({ data });
                    }

                    // ÈªòËÆ§ÂìçÂ∫îÂ§ÑÁêÜ
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1 || data.code === 0 || data.code === 200) {
                            return data.data !== undefined ? data.data : data;
                        }
                        throw new Error(data.message || 'ËØ∑Ê±ÇÂ§±Ë¥•');
                    }

                    return data;
                } catch (error) {
                    console.error('‚ùå Request error:', error);
                    throw error;
                }
            }

            async get(url, params = {}) {
                const query = new URLSearchParams(params).toString();
                const fullUrl = query ? `${url}?${query}` : url;
                return this.request(fullUrl, { method: 'GET' });
            }

            async post(url, data = {}) {
                return this.request(url, {
                    method: 'POST',
                    body: JSON.stringify(data),
                });
            }
        }

        // MAN API ÂÆû‰æã
        const manApi = new HttpRequest(`${CONSTANTS.MAN_BASE_URL}/api`, {
            responseHandler: ({ data }) => {
                return new Promise((resolve, reject) => {
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1) {
                            resolve(data.data);
                        } else {
                            reject({ code: data.code, message: data.message || 'ËØ∑Ê±ÇÂ§±Ë¥•' });
                        }
                    } else {
                        resolve(data.data || data);
                    }
                });
            },
        });

         // ==================== MAN V2 API ====================
        // MAN V2 API Âü∫Á°ÄURL
        const MAN_V2_BASE_URL = CONSTANTS.MAN_V2_BASE_URL;

        // MAN V2 API ÂÆû‰æã
        const manV2Api = new HttpRequest(MAN_V2_BASE_URL, {
            responseHandler: ({ data }) => {
                return new Promise((resolve, reject) => {
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1 || data.code === 200) {
                            resolve(data.data);
                        } else {
                            reject({
                                code: data.code,
                                data: data.data,
                                message: data.message,
                            });
                        }
                    } else {
                        resolve(data.data || data);
                    }
                });
            },
        });

        // Ëé∑ÂèñÊåáÂÆö path ‰∏ãÊâÄÊúâ PinÔºàÂàÜÈ°µÔºâ
        async function getPinListByPath(params) {
            const { cursor = 0, size = 20, path } = params;
            const query = new URLSearchParams({
                cursor: cursor.toString(),
                size: size.toString(),
                path
            }).toString();
            return manV2Api.get('/pin/path/list' + `?${query}`);
        }

           /**
         * 5. Ëé∑ÂèñÊåáÂÆöÂú∞ÂùÄÂíå path ‰∏ã PinÔºàÂÄíÂ∫èÂàÜÈ°µÔºâ
         */
        async function getAddressPinList(params){
        const { address, cursor = 0, size = 20, path } = params
        const query = new URLSearchParams({
        cursor: cursor.toString(),
        size: size.toString(),
        path
        }).toString()
        return manV2Api.get(`/address/pin/list/${address}?${query}`)
        }

        // Ëé∑Âèñ Pin ËØ¶ÊÉÖ
        async function getPinDetail(params) {
            const { numberOrId } = params;
            return manV2Api.get(`/pin/${numberOrId}`);
        }


        // ==================== Meta-Contract Áõ∏ÂÖ≥ÂáΩÊï∞ ====================

        // ËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÂîØ‰∏ÄÈîÆ
        function generateKey() {
            return (
                'key_' +
                Date.now() +
                '_' +
                Math.random()
                    .toString(36)
                    .slice(2, 8)
            );
        }

        // Ëé∑ÂèñÂ≠óÁ¨¶‰∏≤ UTF-8 Â≠óËäÇÂ§ßÂ∞è
        function getStringSize(str) {
            return new TextEncoder().encode(str).length;
        }

        // Âà§Êñ≠ÊòØÂê¶Ë∂ÖËøá 1MB
        function isBiggerThan1MB(str) {
            return getStringSize(str) > 1024 * 1024;
        }

        // ÊûÑÂª∫ MetaID OpReturn V2 Êï∞ÊçÆ
        function buildOpReturnV2(metaidData, options) {
            const res1 = ['metaid', metaidData.operation];
            const res2 = [];

            if (metaidData.operation !== 'init') {
                res2.push(metaidData.path);
                res2.push(metaidData?.encryption ?? '0');
                res2.push(metaidData?.version ?? '1.0.0');
                res2.push(metaidData?.contentType ?? 'text/plain;utf-8');

                const body = metaidData.body == null
                    ? undefined
                    : Buffer.isBuffer(metaidData.body)
                    ? metaidData.body
                    : Buffer.from(metaidData.body, metaidData?.encoding ?? 'utf-8');
                res2.push(body);
            }

            return [...res1, ...res2];
        }

        // ÂπøÊí≠‰∫§ÊòìÂà∞ API
        async function broadcastToApi({ txHex, network, chain = 'mvc' }) {
            try {
                const response = await fetch(`${CONSTANTS.BroadCast_API}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chain: chain,
                        net: network,
                        rawTx: txHex,
                    }),
                });

                const result = await response.json();
                const { data: txid, message } = result;

                if (!txid) {
                    throw new Error(message);
                }

                return { txid };
            } catch (error) {
                console.error('Broadcast error:', error);
                throw error;
            }
        }

        // Âçï‰∏™‰∫§ÊòìÂπøÊí≠
        async function broadcast({ txComposer, network }) {
            const txHex = txComposer.getTx().toString();
            const { txid } = await broadcastToApi({ txHex, network });
            console.log('txid', txid);
            return { txid };
        }

        // ÊâπÈáèÂπøÊí≠‰∫§Êòì
        async function batchBroadcast({ txComposer, network }) {
            const res = [];
            for (let i = 0; i < txComposer.length; i++) {
                const broadcastRes = await broadcast({
                    txComposer: txComposer[i],
                    network,
                });
                res.push(broadcastRes);
            }
            return res;
        }

        // ÊîØ‰ªòÂáΩÊï∞
        async function pay({ transactions, feeb }) {
            const params = {
                transactions: transactions.map(transaction => {
                    return {
                        txComposer: transaction.txComposer.serialize(),
                        message: transaction.message,
                    };
                }),
                hasMetaid: true,
                feeb,
            };

            // Â§ÑÁêÜÂ§ßÊï∞ÊçÆÂàÜÁâáÂ≠òÂÇ®
            if (window.metaidwallet.storageChunk && isBiggerThan1MB(JSON.stringify(params))) {
                const key = generateKey();
                const data = JSON.stringify(params);
                const chunkSize = 256 * 1024; // ÊØèÁâá 256KB
                const total = Math.ceil(data.length / chunkSize);

                for (let i = 0; i < total; i++) {
                    const chunk = data.slice(i * chunkSize, (i + 1) * chunkSize);
                    await window.metaidwallet.storageChunk({ chunk, index: i, total, key });
                }

                const ret = await window.metaidwallet.pay({
                    useChunk: true,
                    chunkKey: key,
                });

                const { payedTransactions, status, message } = ret;

                if (status) {
                    throw new Error(message || status);
                }

                return payedTransactions.map((txComposerSerialized) => {
                    return TxComposer.deserialize(txComposerSerialized);
                });
            }

            // Ê≠£Â∏∏ÊîØ‰ªòÊµÅÁ®ã
            const ret = await window.metaidwallet.pay(params);
            const { payedTransactions, status, message } = ret;

            if (status) {
                throw new Error(message || status);
            }

            return payedTransactions.map((txComposerSerialized) => {
                return TxComposer.deserialize(txComposerSerialized);
            });
        }

        // ‰ΩøÁî® Asset ÂàõÂª∫ Pin
        async function createPinWithAsset(metaidData, options) {
            const address = await window.metaidwallet.getAddress();

            let utxo = options?.utxo;
            if (!utxo) {
                const utxos = await window.metaidwallet.getUtxos();
                utxo = utxos.find(u => u.address === address);

                if (!utxo) {
                    const url = `${options.assistDomain}/v1/assist/gas/mvc/address-init`;
                    const preRes = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            gasChain: 'mvc',
                            address,
                        }),
                    });
                    const initUtxo = await preRes.json();

                    if (initUtxo.error) {
                        throw new Error(initUtxo.error);
                    }

                    if (!initUtxo.data) {
                        await sleep(5000);
                        const utxos = await window.metaidwallet.getUtxos();
                        utxo = utxos.find(u => u.address === address);
                        if (!utxo) {
                            throw new Error('No UTXO found for address');
                        }
                    } else {
                        utxo = {
                            txid: initUtxo.data.txId,
                            outIndex: initUtxo.data.index,
                            value: initUtxo.data.amount,
                            address: initUtxo.data.address,
                        };
                    }
                }
            }

            const pinTxComposer = new TxComposer();
            pinTxComposer.appendP2PKHInput({
                address: new mvc.Address(address, options.network),
                satoshis: utxo.value,
                txId: utxo.txid,
                outputIndex: utxo.outIndex,
            });

            pinTxComposer.appendP2PKHOutput({
                address: new mvc.Address(address, options.network),
                satoshis: 1,
            });

            const metaidOpreturn = buildOpReturnV2(metaidData, {
                network: options?.network ?? 'testnet',
            });
            pinTxComposer.appendOpReturnOutput(metaidOpreturn);

            const changeAddress = new mvc.Address(address, options.network);
            pinTxComposer.appendP2PKHOutput({
                address: changeAddress,
                satoshis: utxo.value,
            });

            const url = `${options.assistDomain}/v1/assist/gas/mvc/pre`;
            const preRes = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    txHex: pinTxComposer.getRawHex(),
                    address,
                }),
            });
            const preData = await preRes.json();

            if (preData.error) {
                throw new Error(preData.error);
            }

            const tx = new mvc.Transaction(preData.data.txHex);
            const txObj = tx.toObject();
            const inputs = txObj.inputs;
            console.log('inputs', inputs);

            // Ëé∑ÂèñÊâÄÊúâÂºïÁî®ÁöÑUTXO‰ø°ÊÅØ
            const utxoPromises = txObj.inputs.map(async (input) => {
                let utxoRawUrl = `https://mvcapi${
                    options.network === 'testnet' ? '-testnet' : ''
                }.cyber3.space/tx/${input.prevTxId}/raw`;

                if (options.network !== 'testnet') {
                    utxoRawUrl = `https://api.microvisionchain.com/open-api-mvc/tx/${input.prevTxId}/raw`;
                }

                const utxoRes = await fetch(utxoRawUrl);
                return await utxoRes.json();
            });
            const _utxos = await Promise.all(utxoPromises);

            // ‰∏∫ÊØè‰∏™inputËÆæÁΩÆÊ≠£Á°ÆÁöÑoutput
            tx.inputs.forEach((input, index) => {
                const _tx = new mvc.Transaction(_utxos[index].hex);
                const utxoOutput = _tx.outputs[input.outputIndex];
                tx.inputs[index].output = new mvc.Transaction.Output({
                    script: utxoOutput.script,
                    satoshis: utxoOutput.satoshis,
                });
            });

            const txComposer = new TxComposer(tx);
            const txComposerSerialize = txComposer.serialize();
            const params = {
                transaction: [
                    {
                        txComposer: txComposerSerialize,
                        toSignInputs: [0],
                    },
                ],
            };

            const [_txComposerSerialize] = await window.metaidwallet.unlockP2PKHInput(params);

            const commitUrl = `${options.assistDomain}/v1/assist/gas/mvc/commit`;
            const commitRes = await fetch(commitUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    txHex: TxComposer.deserialize(_txComposerSerialize).getRawHex(),
                    orderId: preData.data.orderId,
                }),
            });
            const commitData = await commitRes.json();

            if (commitData.code == 1 && !commitData.data) {
                throw new Error(
                    JSON.stringify({
                        state: commitData.code,
                        message: commitData.message,
                    })
                );
            }

            return {
                txid: commitData.data.txId,
                utxo: {
                    txid: commitData.data.txId,
                    outIndex: 2,
                    value: utxo.value,
                    address: address,
                },
            };
        }

        // ÂàõÂª∫ Pin
        async function createPin(metaidData, options) {
            const transactions = options?.transactions ?? [];
            const address = await window.metaidwallet.getAddress();

            const pinTxComposer = new TxComposer();

            pinTxComposer.appendP2PKHOutput({
                address: new mvc.Address(address, options.network),
                satoshis: 1,
            });

            const metaidOpreturn = buildOpReturnV2(metaidData, {
                network: options?.network ?? 'testnet'
            });

            pinTxComposer.appendOpReturnOutput(metaidOpreturn);

            if (options?.service && options?.service.address && options?.service.satoshis) {
                pinTxComposer.appendP2PKHOutput({
                    address: new mvc.Address(options.service.address, options.network),
                    satoshis: Number(options.service.satoshis),
                });
            }

            if (options?.outputs) {
                for (const output of options.outputs) {
                    pinTxComposer.appendP2PKHOutput({
                        address: new mvc.Address(output.address, options.network),
                        satoshis: Number(output.satoshis),
                    });
                }
            }

            transactions.push({
                txComposer: pinTxComposer,
                message: 'Create Pin',
            });

            if (options?.serialAction === 'combo') {
                return { transactions };
            }

            // Â∫îÁî®ÊîØ‰ªò
            const payRes = await pay({
                transactions,
                feeb: options?.feeRate,
            });

            await batchBroadcast({ txComposer: payRes, network: options.network });

            return {
                txid: payRes[payRes.length - 1].getTxId(),
                txids: payRes.map(item => item.getTxId()),
            };
        }

        // ÂàõÂª∫ÊàñÊõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
        async function createOrUpdateUserInfo({ userData, oldUserData, options }) {
            const metaDatas = [];

            if (userData.name) {
                metaDatas.push({
                    operation: oldUserData.nameId ? 'modify' : 'create',
                    body: userData.name,
                    path: oldUserData.nameId ? `@${oldUserData.nameId}` : '/info/name',
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            }

            if (userData.bio) {
                metaDatas.push({
                    operation: oldUserData.bioId ? 'modify' : 'create',
                    body: userData.bio,
                    path: oldUserData.bioId ? `@${oldUserData.bioId}` : '/info/bio',
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            }

            if (userData.avatar) {
                metaDatas.push({
                    operation: oldUserData.avatarId ? 'modify' : 'create',
                    body: userData.avatar,
                    path: oldUserData.avatarId ? `@${oldUserData.avatarId}` : '/info/avatar',
                    encoding: 'base64',
                    contentType: 'image/jpeg;binary',
                    flag: 'metaid',
                });
            }

            if (userData.background) {
                metaDatas.push({
                    operation: oldUserData.backgroundId ? 'modify' : 'create',
                    body: userData.background,
                    path: oldUserData.backgroundId ? `@${oldUserData.backgroundId}` : '/info/background',
                    encoding: 'base64',
                    contentType: 'image/jpeg;binary',
                    flag: 'metaid',
                });
            }

            if (userData.chatpubkey) {
                if (!oldUserData.chatpubkey) {
                    metaDatas.push({
                        operation: 'create',
                        body: userData.chatpubkey,
                        path: `/info/chatpubkey`,
                        encoding: 'utf-8',
                        contentType: 'text/plain',
                        flag: 'metaid',
                    });
                }
            }

            if (metaDatas.length === 0) {
                throw new Error('No user data provided to create user info');
            }

            let _transactions = [];
            let _txids = [];

            if (options.assistDomain && !oldUserData.nameId) {
                let utxo;
                for (let i = 0; i < metaDatas.length; i++) {
                    const metaData = metaDatas[i];
                    const _options = {
                        network: options?.network ?? 'testnet',
                        signMessage: 'create User Info',
                        serialAction: 'finish',
                        assistDomain: options.assistDomain,
                    };

                    if (utxo) {
                        _options.utxo = utxo;
                    }

                    const { txid, utxo: _utxo } = await createPinWithAsset(metaData, _options);
                    utxo = _utxo;

                    if (txid) {
                        _txids.push(txid);
                    }
                }
            } else {
                for (let i = 0; i < metaDatas.length; i++) {
                    const metaData = metaDatas[i];
                    const { transactions, txid, txids } = await createPin(metaData, {
                        network: options?.network ?? 'testnet',
                        signMessage: 'create User Info',
                        serialAction: i === metaDatas.length - 1 ? 'finish' : 'combo',
                        transactions: [..._transactions],
                        feeRate: options?.feeRate,
                    });
                    _transactions = transactions;
                    if (txids) {
                        _txids = txids;
                    }
                }
            }

            const ret = {
                nameRes: undefined,
                bioRes: undefined,
                avatarRes: undefined,
                backgroundRes: undefined,
                chatpubkeyRes: undefined,
            };

            const userInfos = [
                { key: 'name', resKey: 'nameRes' },
                { key: 'bio', resKey: 'bioRes' },
                { key: 'avatar', resKey: 'avatarRes' },
                { key: 'background', resKey: 'backgroundRes' },
                { key: 'chatpubkey', resKey: 'chatpubkeyRes' },
            ];

            for (let i = 0; i < userInfos.length; i++) {
                const { key, resKey } = userInfos[i];
                if (userData[key]) {
                    const txid = _txids.shift();
                    ret[resKey] = { txid };
                }
            }

            return ret;
        }

        // ÂàõÂª∫Áî®Êà∑ÂÖ¨Èí•
        async function createUserPubkey({ pubkey, pubkeyId, options }) {
            const metaDatas = [];

            if (pubkey) {
                const hasPubkey = !!pubkeyId;
                const path = hasPubkey && pubkeyId
                    ? `@{${pubkeyId}}`
                    : `/info/chatpubkey`;

                metaDatas.push({
                    operation: hasPubkey ? 'modify' : 'create',
                    body: pubkey,
                    path: path,
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            } else {
                throw new Error('No Publickey provided to create user info');
            }

            if (metaDatas.length === 0) {
                throw new Error('No user data provided to publickey');
            }

            let _transactions = [];
            let _txids = [];

            for (let i = 0; i < metaDatas.length; i++) {
                const metaData = metaDatas[i];
                const { transactions, txid, txids } = await createPin(metaData, {
                    network: options?.network ?? 'testnet',
                    signMessage: 'create User Info',
                    serialAction: i === metaDatas.length - 1 ? 'finish' : 'combo',
                    transactions: [..._transactions],
                    feeRate: options?.feeRate,
                });
                _transactions = transactions;
                if (txids) {
                    _txids = txids;
                }
            }

            return _txids[0];
        }

        // Ëé∑Âèñ MVC Â•ñÂä±
        async function getMVCRewards(params, signature, options = {}) {
            const response = await fetch(
                `${CONSTANTS.METASO_ASSET_API}/v1/assist/gas/mvc/address-reward`,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Signature': signature['X-Signature'] || '',
                        'X-Public-Key': signature['X-Public-Key'] || '',
                        ...(options?.headers || {}),
                    },
                    body: JSON.stringify(params),
                    ...options,
                }
            );
            return response.json();
        }

        // ==================== ÂõæÁâáÂ§ÑÁêÜÁõ∏ÂÖ≥ÂáΩÊï∞ ====================

        // ÂéãÁº©ÂõæÁâá
        async function compressImage(image) {
            const options = {
                maxSizeMB: 0.3,
                maxWidthOrHeight: 2048,
                useWebWorker: true,
            };
            const compressedFile = await imageCompression(image, options);
            return compressedFile;
        }

        // Êñá‰ª∂ËΩ¨Êç¢‰∏∫ AttachmentItem
        function FileToAttachmentItem(file, encrypt = 0) {
            return new Promise(async resolve => {
                function readResult(blob) {
                    return new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const wordArray = CryptoJS.lib.WordArray.create(reader.result);
                            const buffer = Buffer.from(reader.result);
                            hex += buffer.toString('hex'); // Êõ¥Êñ∞hex
                            sha256Algo.update(wordArray); // Êõ¥Êñ∞hash
                            resolve();
                        };
                        reader.readAsArrayBuffer(blob);
                    });
                }

                // ÂàÜÂùóËØªÂèñÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ∫¢Âá∫ÔºåËøôÈáåËÆæÁΩÆ‰∏∫20MB
                const chunkSize = 20 * 1024 * 1024;
                let hex = ''; // ‰∫åËøõÂà∂
                const sha256Algo = CryptoJS.algo.SHA256.create();

                for (let index = 0; index < file.size; index += chunkSize) {
                    await readResult(file.slice(index, index + chunkSize));
                }

                resolve({
                    data: hex,
                    fileName: file.name,
                    fileType: file.type,
                    sha256: CryptoJS.enc.Hex.stringify(sha256Algo.finalize()),
                    url: URL.createObjectURL(file),
                    encrypt,
                    size: file.size,
                });
            });
        }

        // ÂõæÁâáËΩ¨Êç¢‰∏∫ Attachment
        async function image2Attach(images) {
            const attachments = [];

            for (let i = 0; i < images.length; i++) {
                const current = images[i];
                if (!current) continue;

                // ÂéãÁº©ÂõæÁâáÔºàGIF Èô§Â§ñÔºâ
                const compressed = await compressImage(current);
                const result = await FileToAttachmentItem(
                    current.type === 'image/gif' ? current : compressed
                );
                if (result) attachments.push(result);
            }

            return attachments;
        }

        // Ëé∑Âèñ ECDH ÂÖ¨Èí•
        async function getEcdhPublickey(pubkey) {
            if (!window.metaidwallet) {
                throw new Error('Metalet wallet not found');
            }

            try {
                const ecdh = await window.metaidwallet.common.ecdh({
                    externalPubKey: pubkey || CONSTANTS.MAN_PUB_KEY,
                });
                return ecdh;
            } catch (error) {
                console.error('Failed to get ECDH public key:', error);
                return null;
            }
        }

         // ==================== Âä†ÂØÜ/Ëß£ÂØÜÂ∑•ÂÖ∑ ====================

        /**
         * ÁîüÊàêÊåáÂÆöÈïøÂ∫¶ÁöÑÈöèÊú∫Â≠óËäÇÊï∞ÁªÑÔºà‰ΩøÁî®ÊµèËßàÂô® Web Crypto APIÔºâ
         */
        function randomBytes(length) {
            const buffer = new Uint8Array(length);
            crypto.getRandomValues(buffer);
            return buffer;
        }

        /**
         * Â∞ÜÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ ArrayBuffer
         */
        function hexToArrayBuffer(hex) {
            // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÁ©∫Ê†ºÂíåÊç¢Ë°å
            hex = hex.replace(/\s/g, '');

            if (hex.length % 2 !== 0) {
                throw new Error('ÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶ÂøÖÈ°ªÊòØÂÅ∂Êï∞');
            }

            const buffer = new ArrayBuffer(hex.length / 2);
            const view = new Uint8Array(buffer);

            for (let i = 0; i < hex.length; i += 2) {
                view[i / 2] = parseInt(hex.substring(i, i + 2), 16);
            }

            return buffer;
        }

        /**
         * Â∞Ü Uint8Array ËΩ¨Êç¢‰∏∫ÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤
         */
        function arrayToHex(array) {
            return Array.from(array)
                .map(byte => byte.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * Â∞Ü ArrayBuffer Êàñ Uint8Array ËΩ¨Êç¢‰∏∫ base64 Â≠óÁ¨¶‰∏≤
         */
        function arrayBufferToBase64(buffer) {
            const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /**
         * Â∞Ü base64 Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ ArrayBuffer
         */
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const buffer = new ArrayBuffer(binary.length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) {
                view[i] = binary.charCodeAt(i);
            }
            return buffer;
        }

        /**
         * ‰ΩøÁî®ÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËøõË°å AES-256-GCM Âä†ÂØÜÔºà‰ΩøÁî® Web Crypto APIÔºâ
         */
        async function encryptGCM(plaintext, hexKey) {
            try {
                // ÁîüÊàê 12 Â≠óËäÇÁöÑÈöèÊú∫ IV
                const iv = randomBytes(12);

                // Â∞ÜÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËΩ¨Êç¢‰∏∫ ArrayBuffer
                const keyBuffer = hexToArrayBuffer(hexKey);

                // Ê£ÄÊü•ÂØÜÈí•ÈïøÂ∫¶ (AES-256 ÈúÄË¶Å 32 Â≠óËäÇ)
                if (keyBuffer.byteLength !== 32) {
                    throw new Error(`ÂØÜÈí•ÈïøÂ∫¶ÈîôËØØÔºåÊúüÊúõ32Â≠óËäÇÔºåÂÆûÈôÖ${keyBuffer.byteLength}Â≠óËäÇ`);
                }

                // ÂØºÂÖ•ÂØÜÈí•
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );

                // Â∞ÜÊòéÊñáËΩ¨Êç¢‰∏∫ Uint8Array
                const encoder = new TextEncoder();
                const plaintextBuffer = encoder.encode(plaintext);

                // Âä†ÂØÜ
                const encryptedBuffer = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128 // 16 Â≠óËäÇÁöÑËÆ§ËØÅÊ†áÁ≠æ
                    },
                    cryptoKey,
                    plaintextBuffer
                );

                // ÁªÑÂêà iv + ÂØÜÊñáÔºàÂØÜÊñáÂ∑≤ÂåÖÂê´ËÆ§ËØÅÊ†áÁ≠æÔºâ
                const resultBuffer = new Uint8Array(iv.length + encryptedBuffer.byteLength);
                resultBuffer.set(iv, 0);
                resultBuffer.set(new Uint8Array(encryptedBuffer), iv.length);

                // ËΩ¨Êç¢‰∏∫ base64
                return arrayBufferToBase64(resultBuffer);
            } catch (error) {
                throw new Error(`AES Âä†ÂØÜÂ§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
            }
        }

        /**
         * ‰ΩøÁî®ÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËøõË°å AES-256-GCM Ëß£ÂØÜÔºà‰ΩøÁî® Web Crypto APIÔºâ
         */
        async function decryptGCM(ciphertext, hexKey) {
            try {
                // Ëß£Á†Å base64
                const data = base64ToArrayBuffer(ciphertext);

                // Â∞ÜÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËΩ¨Êç¢‰∏∫ ArrayBuffer
                const keyBuffer = hexToArrayBuffer(hexKey);

                // Ê£ÄÊü•ÂØÜÈí•ÈïøÂ∫¶ (AES-256 ÈúÄË¶Å 32 Â≠óËäÇ)
                if (keyBuffer.byteLength !== 32) {
                    throw new Error(`ÂØÜÈí•ÈïøÂ∫¶ÈîôËØØÔºåÊúüÊúõ32Â≠óËäÇÔºåÂÆûÈôÖ${keyBuffer.byteLength}Â≠óËäÇ`);
                }

                // Ê£ÄÊü•Êï∞ÊçÆÈïøÂ∫¶ (Ëá≥Â∞ëÈúÄË¶Å iv + authTag)
                if (data.byteLength < 28) { // 12 (iv) + 16 (authTag) = 28
                    throw new Error('ÂØÜÊñáÊï∞ÊçÆÂ§™Áü≠');
                }

                // ÊèêÂèñ IV (Ââç 12 Â≠óËäÇ)
                const iv = data.slice(0, 12);

                // ÊèêÂèñÂØÜÊñáÔºàÂåÖÂê´ËÆ§ËØÅÊ†áÁ≠æÔºå‰ªéÁ¨¨ 12 Â≠óËäÇÂà∞ÁªìÂ∞æÔºâ
                const encryptedData = data.slice(12);

                // ÂØºÂÖ•ÂØÜÈí•
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );

                // Ëß£ÂØÜ
                const decryptedBuffer = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128 // 16 Â≠óËäÇÁöÑËÆ§ËØÅÊ†áÁ≠æ
                    },
                    cryptoKey,
                    encryptedData
                );

                // Â∞ÜËß£ÂØÜÂêéÁöÑ ArrayBuffer ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
                const decoder = new TextDecoder();
                return decoder.decode(decryptedBuffer);
            } catch (error) {
                throw new Error(`AES Ëß£ÂØÜÂ§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
            }
        }

        /**
         * ÁîüÊàêÈöèÊú∫ AES-256 ÂØÜÈí• (ÂçÅÂÖ≠ËøõÂà∂Ê†ºÂºè)
         */
        function generateAESKey() {
            const key = randomBytes(32); // 32 Â≠óËäÇ = 256 ‰Ωç
            return arrayToHex(key);
        }

           // ==================== Crypto Store ====================

        /**
         * Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑÁ≠æÂêçÂØÜÈí•
         */
        function queryCurrentSigKey() {
            const userStore = useUserStore();
            if (!userStore.last?.address) {
                return null;
            }

            try {
                const signKeysData = localStorage.getItem('signKeys');
                if (!signKeysData) {
                    return null;
                }

                const signKeys = JSON.parse(signKeysData);
                const signData = signKeys.find(item => item.address === userStore.last.address);
                return signData ? signData.sigKey : null;
            } catch (error) {
                console.error('ËØªÂèñ signKeys Â§±Ë¥•:', error);
                return null;
            }
        }

        /**
         * Á≠æÂêçÊ∂àÊÅØÂπ∂Â≠òÂÇ®Âà∞ localStorage
         */
        async function signMessageAndStore() {
            try {
                const userStore = useUserStore();

                if (!userStore.last?.address) {
                    throw new Error('Áî®Êà∑Âú∞ÂùÄ‰∏çÂ≠òÂú®');
                }

                if (!window.metaidwallet?.signMessage) {
                    throw new Error('metaidwallet.signMessage ÊñπÊ≥ï‰∏çÂèØÁî®');
                }

                const message = userStore.last.address;
                const { signature } = await window.metaidwallet.signMessage(message);

                // ‰ªé localStorage Ëé∑ÂèñÁé∞ÊúâÁöÑ signKeys Êï∞ÁªÑ
                const existingSignKeys = localStorage.getItem('signKeys');
                let signKeys = existingSignKeys ? JSON.parse(existingSignKeys) : [];

                // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÂú∞ÂùÄÁöÑÁ≠æÂêç
                const existingIndex = signKeys.findIndex(item => item.address === message);
                const signItem = {
                    address: message,
                    sigKey: signature.signature.slice(0, 64)
                };

                if (existingIndex >= 0) {
                    // Êõ¥Êñ∞Áé∞ÊúâÁ≠æÂêç
                    signKeys[existingIndex] = signItem;
                } else {
                    // Ê∑ªÂä†Êñ∞Á≠æÂêç
                    signKeys.push(signItem);
                }

                // Â≠òÂÇ®Âà∞ localStorage
                localStorage.setItem('signKeys', JSON.stringify(signKeys));

                return signature.signature.slice(0, 64);
            } catch (error) {
                console.error('Á≠æÂêçÊ∂àÊÅØÂ§±Ë¥•:', error);
                throw error;
            }
        }

        // ==================== Pinia Stores ====================

        // Root Store - Ê†πÁä∂ÊÄÅÁÆ°ÁêÜ
        const useRootStore = defineStore('root', {
            state: () => ({
                isWebView: false
            }),
            actions: {
                // Ê£ÄÊü•ÊòØÂê¶Âú®WebView‰∏≠
                checkWebViewBridge() {
                    const UA = window.navigator.userAgent.toLowerCase();
                    const isAndroid = !!(UA && UA.indexOf('android') > 0);
                    const isIOS = !!(UA && /iphone|ipad|ipod|ios/.test(UA));

                    if (isIOS || isAndroid) {
                        if (window?.navigator) {
                            const userAgent = window?.navigator?.userAgent || '';
                            if (userAgent === 'IDChat-iOS' || userAgent === 'IDChat-Android') {
                                this.isWebView = true;
                                return true;
                            }
                        }
                    }
                    return false;
                },

                // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄÊòØÂê¶‰∏ÄËá¥
                async checkBtcAddressSameAsMvc() {
                    const connectionStore = useConnectionStore();
                    const mvcAddress = await connectionStore.adapter.getMvcAddress();
                    const btcAddress = await connectionStore.adapter.getBtcAddress();

                    if (mvcAddress && btcAddress && mvcAddress !== btcAddress) {
                        throw new Error('BTC Âú∞ÂùÄ‰∏é MVC Âú∞ÂùÄ‰∏ç‰∏ÄËá¥ÔºåËØ∑Á°Æ‰øù‰ΩøÁî®Áõ∏ÂêåÁöÑÈí±ÂåÖÂú∞ÂùÄ');
                    }
                }
            }
        });

        // Network Store - ÁΩëÁªúÁä∂ÊÄÅÁÆ°ÁêÜ
        const useNetworkStore = defineStore('network', {
            getters: {
                network: () => CONSTANTS.NETWORK,
                isTestnet: () => CONSTANTS.NETWORK === 'testnet',
            }
        });

        // Layout Store - Â∏ÉÂ±ÄÁä∂ÊÄÅÁÆ°ÁêÜ
        const useLayoutStore = defineStore('layout', {
            state: () => ({
                isShowProfileEditModal: false
            })
        });

        // User Store - Áî®Êà∑‰ø°ÊÅØÁÆ°ÁêÜ
        const useUserStore = defineStore('user', {
            state: () => ({
                last: useLocalStorage('user-info', {
                    address: '',
                    avatar: '',
                    avatarId: '',
                    background: '',
                    bio: '',
                    bioId: '',
                    blocked: false,
                    chainName: 'mvc',
                    fdv: 0,
                    followCount: 0,
                    isInit: false,
                    metaid: '',
                    name: '',
                    nameId: '',
                    nftAvatar: '',
                    nftAvatarId: '',
                    number: 0,
                    pdv: 0,
                    pinId: '',
                    soulbondToken: '',
                    unconfirmed: '',
                    chatpubkey: '',
                })
            }),
            getters: {
                has: (state) => !!state.last,
                isAuthorized: (state) => {
                    const connectedStore = useConnectionStore();
                    return !!(state.last.address && state.last.metaid && connectedStore.last.status === 'connected');
                }
            },
            actions: {
                async updateUserInfo(userInfo) {
                    this.last = { ...this.last, ...userInfo };
                },

                async setUserInfo(address) {
                    if (!address) return this.last;

                    try {
                        const userRes = await manApi.get(`/info/address/${address}`);
                        if (userRes) {
                            this.last = userRes;

                            // Â¶ÇÊûúÊ≤°ÊúâÁî®Êà∑ÂêçÔºåÊòæÁ§∫ÁºñËæëËµÑÊñôÊ®°ÊÄÅÊ°Ü
                            if (!this.last.name) {
                                const layoutStore = useLayoutStore();
                                layoutStore.isShowProfileEditModal = true;
                            }
                        }
                        return this.last;
                    } catch (e) {
                        const { showToast } = useToast();
                        showToast(e.message, 'error');
                        return this.last;
                    }
                },

                clearUserInfo() {
                    this.last = {
                        address: '',
                        avatar: '',
                        avatarId: '',
                        background: '',
                        bio: '',
                        bioId: '',
                        blocked: false,
                        chainName: 'mvc',
                        fdv: 0,
                        followCount: 0,
                        isInit: false,
                        metaid: '',
                        name: '',
                        nameId: '',
                        nftAvatar: '',
                        nftAvatarId: '',
                        number: 0,
                        pdv: 0,
                        pinId: '',
                        soulbondToken: '',
                        unconfirmed: '',
                        chatpubkey: '',
                    };
                }
            }
        });

        // Credentials Store - Âá≠ËØÅÁÆ°ÁêÜ
        const useCredentialsStore = defineStore('credentials', {
            state: () => ({
                credentials: useLocalStorage('credentials', []),
                signing: false
            }),
            getters: {
                getByAddress: (state) => (address) => {
                    return state.credentials.find(s => s.address === address);
                },
                has: (state) => (address) => {
                    return !!state.credentials.find(s => s.address === address);
                },
                get: (state) => {
                    const connectionStore = useConnectionStore();
                    const connected = connectionStore.connected;
                    const address = connectionStore.getAddress;
                    const credential = state.credentials.find(s => s.address === address);
                    const ready = connected && !!credential;
                    return ready ? credential : false;
                },
                ready: (state) => {
                    const connectionStore = useConnectionStore();
                    const connected = connectionStore.connected;
                    const address = connectionStore.getAddress;
                    const credential = state.credentials.find(s => s.address === address);
                    return connected && !!credential;
                }
            },
            actions: {
                add({ publicKey, signature, address }) {
                    if (this.credentials.find(s => s.address === address)) return;
                    this.credentials.push({ publicKey, signature, address });
                },

                remove(address) {
                    this.credentials = this.credentials.filter(s => s.address !== address);
                },

                clear() {
                    this.credentials = [];
                },

                async sign() {
                    const connectionStore = useConnectionStore();
                    const connection = connectionStore.last;

                    if (!connection.address || connection.status === 'disconnected') {
                        throw new Error('Please connect to a wallet first.');
                    }

                    const address = connectionStore.getAddress;
                    const credential = this.getByAddress(address);
                    if (credential) return credential;

                    this.signing = true;

                    const message = CONSTANTS.SIGNING_MESSAGE;
                    let publicKey = connection.pubKey;
                    let signature = '';

                    try {
                        publicKey = await connectionStore.adapter.getMvcPublickey();
                        signature = await connectionStore.adapter.signMessage(message);

                        this.add({ publicKey, signature, address });
                        return { publicKey, signature, address };
                    } catch (e) {
                        this.signing = false;
                        throw e;
                    }
                },

                async login() {
                    const connectionStore = useConnectionStore();
                    const synced = await connectionStore.sync();
                    if (!synced) return false;

                    const credential = await this.sign();
                    if (!credential) return false;

                    const userStore = useUserStore();
                    await userStore.setUserInfo(credential.address);
                    return credential;
                }
            }
        });

        // Chain Store - Ë¥πÁéáÁÆ°ÁêÜ
        const useChainStore = defineStore('chain', {
            state: () => ({
                state: useLocalStorage('chain-fee-rates', {
                    btc: {
                        fastestFee: 1,
                        halfHourFee: 1,
                        hourFee: 1,
                        economyFee: 1,
                        minimumFee: 1,
                        customizeFee: 1,
                        selectedFeeType: 'economyFee',
                        lastUpdated: 0,
                    },
                    mvc: {
                        fastestFee: 1,
                        halfHourFee: 1,
                        hourFee: 1,
                        economyFee: 1,
                        minimumFee: 1,
                        customizeFee: 1,
                        selectedFeeType: 'fastestFee',
                        lastUpdated: 0,
                    },
                    currentChain: 'mvc',
                })
            }),
            actions: {
                async fetchFeeRates(url) {
                    try {
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return await response.json();
                    } catch (error) {
                        console.error('Failed to fetch fee rates:', error);
                        throw error;
                    }
                },

                async updateBtcFeeRate() {
                    try {
                        const feeRates = await this.fetchFeeRates(CONSTANTS.BTC_FEE_RATE_URL);
                        this.state.btc.fastestFee = feeRates.fastestFee;
                        this.state.btc.halfHourFee = feeRates.halfHourFee;
                        this.state.btc.hourFee = feeRates.hourFee;
                        this.state.btc.economyFee = feeRates.economyFee;
                        this.state.btc.minimumFee = feeRates.minimumFee;
                        this.state.btc.lastUpdated = Date.now();
                    } catch (error) {
                        console.error('Failed to update BTC fee rates:', error);
                    }
                },

                async updateMvcFeeRate() {
                    try {
                        const feeRates = await this.fetchFeeRates(CONSTANTS.MVC_FEE_RATE_URL);
                        this.state.mvc.fastestFee = feeRates.fastestFee;
                        this.state.mvc.halfHourFee = feeRates.halfHourFee;
                        this.state.mvc.hourFee = feeRates.hourFee;
                        this.state.mvc.economyFee = 1;
                        this.state.mvc.minimumFee = feeRates.minimumFee;
                        this.state.mvc.lastUpdated = Date.now();
                    } catch (error) {
                        console.error('Failed to update MVC fee rates:', error);
                    }
                },

                async updateAllFeeRates() {
                    await Promise.allSettled([this.updateBtcFeeRate(), this.updateMvcFeeRate()]);
                },

                setBtcCustomizeFee(feeRate) {
                    this.state.btc.customizeFee = feeRate;
                    this.state.btc.lastUpdated = Date.now();
                },

                setMvcCustomizeFee(feeRate) {
                    this.state.mvc.customizeFee = feeRate;
                    this.state.mvc.lastUpdated = Date.now();
                },

                setBtcFeeType(feeType) {
                    this.state.btc.selectedFeeType = feeType;
                },

                setMvcFeeType(feeType) {
                    this.state.mvc.selectedFeeType = feeType;
                },

                setCurrentChain(chain) {
                    this.state.currentChain = chain;
                },

                btcFeeRate() {
                    return this.state.btc[this.state.btc.selectedFeeType];
                },

                mvcFeeRate() {
                    return this.state.mvc[this.state.mvc.selectedFeeType];
                }
            }
        });

        // Approved Store - ÊîØ‰ªòÊéàÊùÉÁÆ°ÁêÜ
        const useApprovedStore = defineStore('approved', {
            state: () => ({
                last: useLocalStorage('last-approved', {
                    isEnabled: true,
                    isApproved: false,
                    autoPaymentAmount: 10000,
                })
            }),
            getters: {
                has: (state) => !!state.last,
                canUse: (state) => state.last.isEnabled && state.last.isApproved,
                canApproved: (state) => state.last.isEnabled === true && state.last.isApproved === false
            },
            actions: {
                async getPaymentStatus() {
                    const connectionStore = useConnectionStore();
                    const res = await connectionStore.adapter.autoPaymentStatus();
                    this.last = res;
                },

                async getAutoPayment() {
                    if (this.canApproved) {
                        const connectionStore = useConnectionStore();
                        const res = await connectionStore.adapter.autoPayment();
                        if (res.message === "Auto payment approved") {
                            this.last.isApproved = true;
                        }
                    }
                },

                clear() {
                    if (!this.last) return;
                    this.last.isEnabled = true;
                    this.last.isApproved = false;
                    this.last.autoPaymentAmount = 10000;
                }
            }
        });

        // Connection Store - Èí±ÂåÖËøûÊé•ÁÆ°ÁêÜ
        const useConnectionStore = defineStore('connection', {
            state: () => ({
                last: useLocalStorage('last-connection', {
                    wallet: 'metalet',
                    status: 'disconnected',
                    address: '',
                    pubKey: '',
                })
            }),
            getters: {
                has: (state) => !!state.last,
                connected: (state) => state.last.status === 'connected' && !!state.last.address,
                getAddress: (state) => state.last.address,
                isTaproot: (state) => state.last.address.startsWith('bc1p') || state.last.address.startsWith('tb1p'),
                getPubKey: (state) => state.last.pubKey,
                provider: (state) => {
                    if (!state.last) return null;
                    return window.metaidwallet;
                },
                adapter: (state) => {
                    if (!state.last) throw new Error('No connection');
                    return getWalletAdapter(state.last.wallet);
                }
            },
            actions: {
                async connect(wallet) {
                    const connection = this.last ? JSON.parse(JSON.stringify(this.last)) : {
                        wallet,
                        status: 'disconnected',
                        address: '',
                        pubKey: '',
                    };

                    try {
                        let connectRes = await getWalletAdapter(wallet).connect();

                        if (connectRes) {
                            const networkStore = useNetworkStore();
                            const appNetwork = networkStore.network;

                            // Ê£ÄÊü•Âπ∂ÂàáÊç¢ÁΩëÁªú
                            const metaNetwork = await getWalletAdapter('metalet').getNetwork();
                            if (metaNetwork !== appNetwork) {
                                await getWalletAdapter('metalet').switchNetwork(appNetwork);
                                connectRes = await getWalletAdapter('metalet').connect();
                            }

                            connection.address = connectRes.address;
                            connection.pubKey = connectRes.pubKey;
                            connection.status = 'connected';
                            connection.wallet = wallet;

                            this.last = connection;
                            return this.last;
                        }
                    } catch (e) {
                        const { showToast } = useToast();
                        showToast(e.message, 'error');
                        connection.status = 'disconnected';
                        connection.wallet = wallet;
                        this.last = connection;
                    }

                    return this.last;
                },

                async sync() {
                    if (!this.connected) return;

                    this.last.status = 'connected';
                    this.last.address = await this.adapter.getAddress();
                    this.last.pubKey = await this.adapter.getMvcPublickey();

                    const networkStore = useNetworkStore();
                    const appNetwork = networkStore.network;
                    let networkSynced = true;

                    const network = await this.adapter.getNetwork();
                    if (network !== appNetwork) {
                        networkSynced = false;
                        this.disconnect();
                    } else {
                        const userStore = useUserStore();
                        await userStore.setUserInfo(this.last.address);
                    }

                    if (networkSynced) {
                        return this.last;
                    }
                },

                async disconnect() {
                    if (!this.last) return;

                    this.last.status = 'disconnected';
                    this.last.address = '';
                    this.last.pubKey = '';
                    this.last.wallet = 'metalet';

                    const userStore = useUserStore();
                    const approvedStore = useApprovedStore();
                    const credentialsStore = useCredentialsStore();

                    await userStore.clearUserInfo();
                    credentialsStore.clear();

                    if (window.metaidwallet?.smallPay) {
                        await approvedStore.clear();
                    }
                }
            }
        });

        // ==================== Metalet Èí±ÂåÖÈÄÇÈÖçÂô® ====================
        // Ê£ÄÊü•MetaletÈí±ÂåÖ
        function checkMetalet() {
            const connectionStore = useConnectionStore();
            if (!window.metaidwallet && !connectionStore.connected) {
                throw new Error('Please install the Metalet wallet extension first.');
            }
        }

        // Ê£ÄÊü•MetaletÁä∂ÊÄÅ
        function checkMetaletStatus(res, actionName) {
            if (res?.status) {
                throw new Error(`Metalet ${actionName} status: ${res?.status}`);
            }
            return res;
        }

        // MetaletÈÄÇÈÖçÂô®ÂØπË±°
        const getWalletAdapter = (wallet) => {
            if (wallet !== 'metalet') {
                throw new Error(`Unsupported wallet: ${wallet}`);
            }

            return {
                async connect() {
                    checkMetalet();
                    const connectRes = await window.metaidwallet.connect();
                    return checkMetaletStatus(connectRes, 'connect');
                },

                async getMvcAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.getAddress();
                    return checkMetaletStatus(addressRes, 'get address');
                },

                async getBtcAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.btc.getAddress();
                    return checkMetaletStatus(addressRes, 'get btc address');
                },

                async getMvcBalance() {
                    checkMetalet();
                    return await window.metaidwallet.getMvcBalance();
                },

                async signMvcMessage(message) {
                    checkMetalet();
                    const { signature } = await window.metaidwallet.signMessage({ message });
                    const buf = Buffer.from(signature.signature, 'hex');
                    return buf.toString('base64');
                },

                async getMvcPublickey() {
                    checkMetalet();
                    const MvcPubkey = await window.metaidwallet.getPublicKey();
                    return checkMetaletStatus(MvcPubkey, 'get mvc publickey');
                },

                async getAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.getAddress();
                    return checkMetaletStatus(addressRes, 'get address');
                },

                async getNetwork() {
                    checkMetalet();
                    return await window.metaidwallet.getNetwork().then(({ network }) => {
                        if (network === 'mainnet') {
                            return 'livenet';
                        }
                        return 'testnet';
                    });
                },

                async switchNetwork(network) {
                    checkMetalet();
                    return await window.metaidwallet.switchNetwork(network === 'livenet' ? 'mainnet' : 'testnet').then((res) => {
                        if (res.status === 'canceled') {
                            throw new Error('Switch network canceled');
                        }
                        if (res.network === 'mainnet') {
                            return 'livenet';
                        }
                        return 'testnet';
                    });
                },

                async disconnect() {},

                async signMessage(message) {
                    checkMetalet();
                    const messageBase64 = await window.metaidwallet.btc.signMessage(message);
                    return checkMetaletStatus(messageBase64, 'get signature');
                },

                async autoPaymentStatus() {
                    checkMetalet();
                    return await window.metaidwallet.autoPaymentStatus();
                },

                async autoPayment() {
                    checkMetalet();
                    return await window.metaidwallet.autoPayment();
                }
            };
        };

        // ==================== Connection Modal State ====================
        const useConnectionModal = createGlobalState(() => {
            const isConnectionModalOpen = ref(false);
            const isWalletMissingModalOpen = ref(false);
            const missingWallet = ref();

            const openConnectionModal = () => {
                isConnectionModalOpen.value = true;
            };

            const closeConnectionModal = () => {
                isConnectionModalOpen.value = false;
            };

            const openWalletMissingModal = () => {
                isWalletMissingModalOpen.value = true;
            };

            const closeWalletMissingModal = () => {
                isWalletMissingModalOpen.value = false;
            };

            const setMissingWallet = (wallet) => {
                missingWallet.value = wallet;
                openWalletMissingModal();
            };

            return {
                isConnectionModalOpen,
                openConnectionModal,
                closeConnectionModal,
                isWalletMissingModalOpen,
                openWalletMissingModal,
                closeWalletMissingModal,
                missingWallet,
                setMissingWallet,
            };
        });

        // ==================== MetaFs Ê†∏ÂøÉÊñπÊ≥ï ====================
        /**
 * Complete direct upload flow
 */
async function uploadFileToChainDirect(file) {
    try {
      

        // 2. Build ContentType
        let contentType = file.type || 'application/octet-stream';
        if (!contentType.includes(';binary')) {
            contentType = contentType + ';binary';
        }
        
        // 3. Estimate upload fee
        const estimatedFee = await estimateUploadFee(file);
        console.log('üí∞ Estimated fee:', estimatedFee, 'satoshis');
        
        // 4. Get UTXOs
        const utxos = await getWalletUTXOs(estimatedFee);
        console.log('‚úÖ Got', utxos.utxos.length, 'UTXO(s), total:', utxos.totalAmount, 'satoshis');
        
        // 5. Merge UTXOs if needed
        let finalUtxo = null;
        let mergeTxHex = '';
        
        if (utxos.utxos.length > 1) {
            console.log('‚ö†Ô∏è Multiple UTXOs detected, merging...');
            const mergeResult = await mergeUTXOs(utxos, estimatedFee);
            finalUtxo = {
                utxos: mergeResult.utxos,
                totalAmount: mergeResult.totalAmount
            };
            mergeTxHex = mergeResult.mergeTxHex || '';
            console.log('‚úÖ UTXOs merged successfully');
        } else {
            finalUtxo = {
                utxos: utxos.utxos,
                totalAmount: utxos.totalAmount
            };
            console.log('‚úÖ Single UTXO, no merge needed');
        }
        
        // 6. Build and sign base transaction
        console.log('Please confirm signature in wallet...');
        const preTxHex = await buildAndSignBaseTx(finalUtxo);
        console.log('‚úÖ Base transaction signed');
        
        // 7. Direct upload (one-step: add OP_RETURN + calculate change + broadcast)
        const uploadResult = await directUpload(file,preTxHex, finalUtxo.totalAmount, mergeTxHex);
        
        console.log('‚úÖ File uploaded successfully!');
        console.log('TxID:', uploadResult.txId);
        console.log('PinID:', uploadResult.pinId);
        
        return uploadResult;
        
    } catch (error) {
        console.error('‚ùå Direct upload failed:', error.message);
        throw error;
    }
}


async function estimateUploadFee(file) {
    // Base transaction size estimation
    const baseSize = 200; // Basic transaction overhead
    const inputSize = 150; // Per input size (with signature)
    const outputSize = 34; // Per output size
    const opReturnOverhead = 50; // OP_RETURN script overhead
     const chainStore = useChainStore();
      
    // File size
    const fileSize = file.size;
    
    // Calculate OP_RETURN output size
    // MetaID protocol: metaid + operation + path + encryption + version + contentType + content
    const path = '/file'
    const fileHost = '';
    const finalPath = fileHost ? fileHost + ':' + path : path;
    
    const metadataSize = 6 + 10 + finalPath.length + 10 + 10 + 50; // Rough estimate
    const opReturnSize = opReturnOverhead + metadataSize + fileSize;
    
    // Total transaction size estimation (1 input, 2 outputs: change + OP_RETURN)
    const estimatedTxSize = baseSize + inputSize + outputSize * 2 + opReturnSize;
    
    // Get fee rate
    const feeRate =chainStore.mvcFeeRate() || 1;
    
    // Calculate fee
    const estimatedFee = Math.ceil(estimatedTxSize * feeRate);
    
    // Add safety margin (20%)
    const feeWithMargin = Math.ceil(estimatedFee * 1.2);
    
    console.log('Estimated tx size:', estimatedTxSize, 'bytes');
    console.log('Fee rate:', feeRate, 'sat/byte');
    console.log('Estimated fee (with 20% margin):', feeWithMargin, 'satoshis');
    
    return feeWithMargin;
}

async function getWalletUTXOs(requiredAmount) {
    try {
        // Get UTXOs from wallet
        const utxos = await window.metaidwallet.getUtxos();
        
        if (!utxos || utxos.length === 0) {
            throw new Error('No available UTXOs in wallet');
        }

        // Filter UTXOs: only select UTXOs > 600 satoshis (to ensure change output is possible)
        const filler = 600;
        const fillerUtxos = utxos.filter(utxo => utxo.value > filler);
        
        if (!fillerUtxos || fillerUtxos.length === 0) {
            throw new Error('No UTXOs larger than 600 satoshis available in wallet');
        }

        // Sort UTXOs by amount (descending)
        const sortedUtxos = fillerUtxos.sort((a, b) => b.value - a.value);
        
      
        
        // Select UTXOs to meet required amount
        let selectedUtxos = [];
        let totalAmount = 0;
        
        for (const utxo of sortedUtxos) {
            // Convert address to script
            let scriptHex = mvc.Script.buildPublicKeyHashOut(utxo.address).toHex();
            selectedUtxos.push({
                txId: utxo.txid,
                outputIndex: utxo.outIndex,
                script: scriptHex,
                satoshis: utxo.value
            });
            totalAmount += utxo.value;
            
            // Add buffer for change output (1 satoshi for receiver)
            if (totalAmount >= requiredAmount + 1) {
                break;
            }
        }

        if (totalAmount < requiredAmount + 1) {
            throw new Error(`Insufficient balance! Need ${requiredAmount + 1} satoshis, but only have ${totalAmount} satoshis`);
        }
        
        return {
            utxos: selectedUtxos,
            totalAmount: totalAmount
        };
    } catch (error) {
        console.error('Failed to get UTXOs:', error);
        throw new Error(`Failed to get UTXOs: ${error.message}`);
    }
}

async function mergeUTXOs(utxoData, estimatedFee) {
    try {
        // Check if pay method is available
        if (typeof window.metaidwallet.pay !== 'function') {
            throw new Error('Wallet does not support pay method');
        }
        
        // Get meta-contract library for TxComposer
       
        
        
        // Create merge transaction - we only specify the output
        // pay method will automatically select inputs, add change, and sign
        const mergeTx = new mvc.Transaction();
        mergeTx.version = 10;
        
        // Add single output to ourselves (this will merge all UTXOs into one)
        mergeTx.to(currentAddress, estimatedFee); 
        
        // Create TxComposer for pay method
        const txComposer = new TxComposer(mergeTx);
        const txComposerSerialize = txComposer.serialize();
        
        // Build pay params
        const feeRate = chainStore.mvcFeeRate() || 1;
        const payParams = {
            transactions: [
                {
                    txComposer: txComposerSerialize,
                    message: 'Merge UTXOs',
                }
            ],
            feeb: feeRate,
        };
        
        // Call pay method - it will auto select inputs, add change, and sign
        const payResult = await window.metaidwallet.pay(payParams);
        
        // Deserialize the payed transaction
        const payedTxComposerStr = payResult.payedTransactions[0];
        const payedTxComposer = TxComposer.deserialize(payedTxComposerStr);
        
        // Get signed transaction hex
        const signedMergeTxHex = payedTxComposer.getRawHex();
        const mergeTxId = payedTxComposer.getTxId();
        
        // Parse the transaction to get output info
        const parsedMergeTx = new mvc.Transaction(signedMergeTxHex);
        
        // Find the output that goes to our address (the merged UTXO)
        let mergedOutputIndex = -1;
        let mergedOutputAmount = 0;
        
        for (let i = 0; i < parsedMergeTx.outputs.length; i++) {
            const output = parsedMergeTx.outputs[i];
            try {
                const addr = output.script.toAddress(mvc.Networks.livenet);
                if (addr && addr.toString() === currentAddress) {
                    mergedOutputIndex = i;
                    mergedOutputAmount = output.satoshis;
                    break;
                }
            } catch (e) {
                continue;
            }
        }
        
        if (mergedOutputIndex === -1) {
            // Fallback: use the first output
            mergedOutputIndex = 0;
            mergedOutputAmount = parsedMergeTx.outputs[0].satoshis;
        }
        
        // Create new UTXO info from merge transaction
        const newUtxo = {
            txId: mergeTxId,
            outputIndex: mergedOutputIndex,
            script: parsedMergeTx.outputs[mergedOutputIndex].script.toHex(),
            satoshis: mergedOutputAmount
        };
        
        return {
            utxos: [newUtxo],
            totalAmount: newUtxo.satoshis,
            mergeTxId: mergeTxId,
            mergeTxHex: signedMergeTxHex
        };
        
    } catch (error) {
        console.error('Failed to merge UTXOs:', error);
        throw new Error(`Failed to merge UTXOs: ${error.message}`);
    }
}

async function buildAndSignBaseTx(utxoData) {
    try {
        // Validate: must have exactly one UTXO for SIGHASH_SINGLE
        if (!utxoData.utxos || utxoData.utxos.length !== 1) {
            throw new Error(`SIGHASH_SINGLE requires exactly 1 UTXO, got ${utxoData.utxos ? utxoData.utxos.length : 0}`);
        }
       
         const userStore = useUserStore();
        
       
        
        const utxo = utxoData.utxos[0]; // Single UTXO
        
        // Create new transaction
        const tx = new mvc.Transaction();
        tx.version = 10; // MVC version
        
        // Add single input
        tx.from({
            txId: utxo.txId,
            outputIndex: utxo.outputIndex,
            script: utxo.script,
            satoshis: utxo.satoshis
        });
        
        // Add receiver output (1 satoshi)
        tx.to(userStore.last.address, 1);
        
        // Serialize to hex
        const txHex = tx.toString();
        
        // Sign the single input with SIGHASH_SINGLE
        const signResult = await window.metaidwallet.signTransaction({
            transaction: {
                txHex: tx.toString(),
                address: userStore.last.address,
                inputIndex: 0,
                scriptHex: utxo.script,
                satoshis: utxo.satoshis,
                sigtype: 0x3 | 0x80 | 0x40 // SIGHASH_SINGLE | ANYONE_CAN_PAY
            }
        });
        
        if (!signResult || !signResult.signature || !signResult.signature.sig) {
            throw new Error('Failed to get signature');
        }
        
        // Build unlocking script (scriptSig) from signature
        const sig = signResult.signature.sig;
        const publicKey = signResult.signature.publicKey;
        
        // Build P2PKH unlocking script: <sig> <pubkey>
        const unlockingScript = mvc.Script.buildPublicKeyHashIn(
            publicKey,
            mvc.crypto.Signature.fromTxFormat(Buffer.from(sig, 'hex')).toDER(),
            0x3 | 0x80 | 0x40 // SIGHASH_SINGLE | ANYONE_CAN_PAY
        );

        // Set the unlocking script for this input
        tx.inputs[0].setScript(unlockingScript);
        
        // Get final signed transaction hex
        const signedTxHex = tx.toString();
        
        return signedTxHex;
        
    } catch (error) {
        console.error('Failed to build/sign MVC transaction:', error);
        throw new Error(`Failed to build/sign MVC transaction: ${error.message}`);
    }
}

async function directUpload(file,preTxHex, totalInputAmount, mergeTxHex) {
    try {
         const chainStore = useChainStore();
         const userStore = useUserStore();
        
        // Build contentType
        let contentType = file.type || 'application/octet-stream';
        if (!contentType.includes(';binary')) {
            contentType = contentType + ';binary';
        }
        
        const path = '/file';
        
        // Add host information to path if provided
        const fileHost ='';
        let finalPath = path;
        if (fileHost) {
            finalPath = fileHost + ':' + path;
        }
        
        const formData = new FormData();
        formData.append('file',file);
        formData.append('path',finalPath);
        if (mergeTxHex) {
            formData.append('mergeTxHex',mergeTxHex);
        }
        formData.append('preTxHex',preTxHex);
        formData.append('operation','create');
        formData.append('contentType',contentType);
        formData.append('metaId',userStore.last.metaid);
        formData.append('address',userStore.last.address);
        formData.append('changeAddress',userStore.last.address);
        formData.append('feeRate',chainStore.mvcFeeRate().toString() || '1');
        formData.append('totalInputAmount',totalInputAmount.toString());
        
        const response = await fetch(`${CONSTANTS.METAFS_API_BASE}/api/v1/files/direct-upload`, {
            method: 'POST',
            body: formData,
          
            mode: 'cors',
            headers: {
        // ‰∏çË¶ÅÊâãÂä®ËÆæÁΩÆ Content-TypeÔºåFormData ‰ºöËá™Âä®ËÆæÁΩÆÊ≠£Á°ÆÁöÑ boundary
        // 'Content-Type': 'multipart/form-data' // ‚Üê Âà†Èô§ËøôË°å
    },
        });
        
        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.code !== 0) {
            throw new Error(result.message);
        }
        
        console.log('DirectUpload success!');
        console.log('TxID:', result.data.txId);
        console.log('Status:', result.data.status);
        
        return result.data;
    } catch (error) {
        console.error('DirectUpload failed:', error);
        throw new Error(`DirectUpload failed: ${error.message}`);
    }
}

        // ==================== Vue ÁªÑ‰ª∂ÂÆö‰πâ ====================

        // Toast/Alert ÁªÑ‰ª∂
        const ToastContainer = {
            template: `
                <div class="toast toast-top toast-end z-[10000]">
                    <div v-for="alert in alerts" :key="alert.id"
                         :class="['alert', alertClass(alert.type)]"
                         class="shadow-lg">
                        <span>{{ alert.message }}</span>
                    </div>
                </div>
            `,
            setup() {
                const { alerts } = useToast();

                const alertClass = (type) => {
                    const classes = {
                        'success': 'alert-success',
                        'error': 'alert-error',
                        'warning': 'alert-warning',
                        'info': 'alert-info',
                    };
                    return classes[type] || 'alert-info';
                };

                return { alerts, alertClass };
            }
        };

        // ËøûÊé•Èí±ÂåÖÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const ConnectWalletModal = {
            template: `
                <div v-if="isConnectionModalOpen" class="modal modal-open">
                    <div class="modal-box relative">
                        <button v-if="!loading"
                                class="btn btn-sm btn-circle absolute right-2 top-2"
                                @click="closeConnectionModal">
                            ‚úï
                        </button>

                        <h3 class="font-bold text-lg mb-4">ËøûÊé•Èí±ÂåÖ</h3>

                        <div class="space-y-3">
                            <button class="btn btn-outline w-full justify-start gap-3"
                                    @click="connectMetalet"
                                    :disabled="loading">
                                <div class="w-10 h-10 flex items-center justify-center">
                                   
<svg xmlns="http://www.w3.org/2000/svg" fill="none" width="130" height="130" viewBox="0 0 130 130"><defs><linearGradient x1=".5" y1="0" x2=".5" y2="1" id="a"><stop offset="30.205%" stop-color="#C7FCFF"/><stop offset="100%" stop-color="#FFF"/></linearGradient><linearGradient x1="1.012" y1=".5" x2=".006" y2=".5" id="b"><stop offset="0%" stop-color="#171AFF"/><stop offset="100%" stop-color="#72F5F6"/></linearGradient><linearGradient x1="1.012" y1=".5" x2=".006" y2=".5" id="c"><stop offset="0%" stop-color="#171AFF"/><stop offset="100%" stop-color="#72F5F6"/></linearGradient></defs><path d="m24.917 40.083-16.25-22.75L43.333 26 65 22.75 86.667 26l34.667-8.667-16.25 22.75v23.834l10.833 11.916-2.167 8.667-6.5-3.25 8.667 10.833-2.167 9.75-15.167-7.583-3.25 8.667-10.833 6.5-4.333-6.5-5.417 5.416-9.75 4.334-9.75-4.334-5.417-5.416-4.333 6.5-10.833-6.5-3.25-8.667-15.167 7.583-2.167-9.75L22.75 81.25l-6.5 3.25-2.167-8.667 10.834-11.916V40.083Z" fill-rule="evenodd" fill="url(#a)"/><path d="m74.24 59.702 16.932-19.35a12.948 12.948 0 0 1 3.078 8.4c0 7.18-5.82 13-13 13a12.94 12.94 0 0 1-7.01-2.05Zm-35.412-19.35 16.932 19.35a12.94 12.94 0 0 1-7.01 2.05c-7.18 0-13-5.82-13-13 0-3.203 1.158-6.135 3.078-8.4Z" fill-rule="evenodd" fill="#FFF"/><path d="m77.877 55.546 9.658-11.039a7.583 7.583 0 0 1-9.658 11.038ZM42.465 44.507l9.658 11.039a7.583 7.583 0 0 1-9.658-11.038Z" fill-rule="evenodd" fill="#182A72"/><path d="m8.667 17.333 27.083 19.5 22.75 26L65 76.917l6.5-14.084 22.75-26 27.084-19.5L86.667 26 65 22.75 43.333 26 8.667 17.333Z" fill="url(#b)" opacity=".5"/><path d="M43.333 26 65 54.742 52 24.917 43.333 26ZM65 54.742 86.667 26l-8.603-1.083L65 54.742Z" fill="#EBFEFF"/><path d="M24.917 63.917V40.083l-16.25-22.75L43.333 26 65 22.75 86.667 26l28.682-7.17 5.985-1.497-3.586 5.02-12.665 17.73v23.834l10.834 11.916-1.173 4.692-.703 2.81-.291 1.165-3.665-1.832-2.835-1.418 5.963 7.454 2.704 3.38-1.272 5.724-.895 4.025-15.167-7.583-1.412 3.766-1.838 4.9-10.833 6.5-2.07-3.105-2.263-3.394-5.417 5.416-9.75 4.334-9.75-4.334-2.532-2.532-2.885-2.884-2.262 3.394-2.071 3.106-10.833-6.5-1.838-4.901-1.412-3.766-3.598 1.799-7.881 3.94-3.688 1.844-.894-4.025-1.273-5.725 2.704-3.38 5.963-7.453-2.835 1.418L16.25 84.5l-.291-1.164-.703-2.811-1.173-4.692 10.834-11.916Zm3.255-26.159-9.936-13.91 24.901 6.226L65 26.794l21.863 3.28 24.9-6.225-10.68 14.952v26.662l10.434 11.477-.438 1.752-18.33-9.164 18.848 23.558-.64 2.879-14.559-7.28-4.32 11.52-6.365 3.82-4.925-7.387-8.341 8.342L65 108.29l-7.447-3.31-8.341-8.342-4.925 7.386-6.365-3.819-4.32-11.52-14.559 7.28-.64-2.88L37.25 69.529l-18.329 9.164-.438-1.752 10.434-11.477V38.801l-.745-1.043Z" fill-rule="evenodd" fill="url(#c)"/><path d="m65 76.917-6.5-14.084L65 55.25l6.5 7.583L65 76.917Z" fill-rule="evenodd" fill="#182A72"/></svg>
                                </div>
                                <div class="text-left flex-1">
                                    <div class="font-semibold">Metalet</div>
                                    <span class="text-sm text-gray-500">Connect to Metalet Wallet</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const { isConnectionModalOpen, closeConnectionModal, setMissingWallet } = useConnectionModal();
                const connectionStore = useConnectionStore();
                const credentialsStore = useCredentialsStore();
                const rootStore = useRootStore();
                const { showToast } = useToast();
                const loading = ref(false);

                const connectMetalet = async () => {
                    if (!window.metaidwallet) {
                        setMissingWallet('metalet');
                        return;
                    }

                    try {
                        loading.value = true;
                        const connection = await connectionStore.connect('metalet');

                        if (connection?.status === 'connected') {
                            await credentialsStore.login();
                            await sleep(300);
                            closeConnectionModal();
                        }

                        // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄÊòØÂê¶‰∏ÄËá¥
                        rootStore.checkBtcAddressSameAsMvc()
                            .catch(() => {
                                showToast('BTC Âú∞ÂùÄ‰∏é MVC Âú∞ÂùÄ‰∏ç‰∏ÄËá¥', 'warning');
                            });
                    } catch (err) {
                        showToast(err.message, 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                return {
                    isConnectionModalOpen,
                    closeConnectionModal,
                    connectMetalet,
                    loading
                };
            }
        };

        // Áî®Êà∑Â§¥ÂÉèÁªÑ‰ª∂
        const UserAvatar = {
            props: {
                image: String,
                metaId: String,
                name: String
            },
            template: `
                <div class="avatar">
                    <div class="w-10 h-10 rounded-full">
                        <img :src="avatarSrc" :alt="name || 'User'" class="user-avatar" />
                    </div>
                </div>
            `,
            setup(props) {
                const avatarSrc = computed(() => {
                    if (props.image) {
                        return `${CONSTANTS.MAN_BASE_URL}${props.image}`;
                    }
                    // ÈªòËÆ§Â§¥ÂÉè
                    return 'data:image/png;base64,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';
                });

                return { avatarSrc };
            }
        };

        // ProfileEditModal - Áî®Êà∑ËµÑÊñôÁºñËæëÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const ProfileEditModal = {
            props: {
                modelValue: Boolean
            },
            emits: ['update:modelValue'],
            template: `
                <div v-if="modelValue" class="modal modal-open">
                    <div class="modal-box w-full max-w-[500px] relative">
                        <!-- ÂÖ≥Èó≠ÊåâÈíÆ -->
                        <button
                            class="btn btn-sm btn-circle absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-14 bg-base-200 hover:bg-base-300"
                            @click="closeModal">
                            ‚úï
                        </button>

                        <h3 class="font-bold text-2xl text-center mb-2">Set Up Your Profile</h3>
                        <p class="text-center text-base-content/60 mb-6">
                            Make your account stand out ‚Äî add a unique avatar and display name!
                        </p>

                        <!-- Â§¥ÂÉè‰∏ä‰º†Âå∫Âüü -->
                        <div class="flex justify-center mb-6">
                            <div class="relative">
                                <input
                                    ref="fileInput"
                                    type="file"
                                    @change="handleFileChange"
                                    accept="image/jpeg,image/png"
                                    class="hidden"
                                    id="avatar-upload"
                                />
                                <label for="avatar-upload" class="cursor-pointer">
                                    <img
                                        :src="imageUrl || currentAvatar"
                                        alt="Avatar Preview"
                                        class="w-28 h-28 rounded-[33%] object-cover border-2 border-black"
                                    />
                                </label>
                                <!-- Áõ∏Êú∫ÂõæÊ†áÊåâÈíÆ -->
                                <button
                                    type="button"
                                    @click="triggerFileInput"
                                    class="absolute bottom-4 right-0 w-6 h-6 rounded-full bg-primary hover:bg-primary-focus text-primary-content flex items-center justify-center transition-colors shadow-lg">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Áî®Êà∑ÂêçËæìÂÖ• -->
                        <div class="form-control mb-4">
                            <label class="label">
                                <span class="label-text font-medium">User Name</span>
                            </label>
                            <input
                                v-model="username"
                                type="text"
                                placeholder="What's Your MetaWeb User Name?"
                                class="input input-bordered w-full"
                            />
                        </div>

                        <!-- ‰∏™‰∫∫ÁÆÄ‰ªãËæìÂÖ• -->
                        <div class="form-control mb-6">
                            <label class="label">
                                <span class="label-text font-medium">Profile</span>
                            </label>
                            <input
                                v-model="profile"
                                type="text"
                                placeholder="Profile (Optional)"
                                class="input input-bordered w-full"
                            />
                        </div>

                        <!-- Êèê‰∫§ÊåâÈíÆ -->
                        <div class="flex justify-end">
                            <button
                                type="button"
                                @click="save"
                                :disabled="!hasChanges || loading"
                                :class="['btn btn-circle', hasChanges && !loading ? 'btn-primary' : 'btn-disabled']">
                                <svg v-if="!loading" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                </svg>
                                <span v-else class="loading loading-spinner"></span>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                const userStore = useUserStore();
                const { showToast } = useToast();

                const fileInput = ref(null);
                const username = ref('');
                const profile = ref('');
                const imageUrl = ref('');
                const currentAvatar = ref('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"%3E%3Cpath d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/%3E%3C/svg%3E');
                const imgRaw = ref(null);
                const loading = ref(false);

                // ÁõëÂê¨Áî®Êà∑Â§¥ÂÉèÂèòÂåñ
                watch(
                    () => userStore.last?.avatar,
                    (newAvatar) => {
                        if (newAvatar && newAvatar.startsWith('http')) {
                            currentAvatar.value = newAvatar;
                        }
                    },
                    { immediate: true }
                );

                // ÁõëÂê¨Ê®°ÊÄÅÊ°ÜÊâìÂºÄ/ÂÖ≥Èó≠
                watch(
                    () => props.modelValue,
                    (newVal) => {
                        if (newVal) {
                            // Ê®°ÊÄÅÊ°ÜÊâìÂºÄÊó∂ÂàùÂßãÂåñË°®ÂçïÊï∞ÊçÆ
                            username.value = userStore.last?.name || '';
                            profile.value = userStore.last?.bio || '';
                            imageUrl.value = '';
                            imgRaw.value = null;
                        }
                    }
                );

                // ËÆ°ÁÆóÊòØÂê¶ÊúâÂèòÊõ¥
                const hasChanges = computed(() => {
                    return (
                        imageUrl.value ||
                        username.value !== (userStore.last?.name || '') ||
                        profile.value !== (userStore.last?.bio || '')
                    );
                });

                // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
                const triggerFileInput = () => {
                    fileInput.value?.click();
                };

                // Â§ÑÁêÜÊñá‰ª∂ÈÄâÊã©
                const handleFileChange = async (event) => {
                    const target = event.target;
                    const file = target.files?.[0];

                    if (!file) return;

                    // È™åËØÅÊñá‰ª∂Á±ªÂûã
                    if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
                        showToast('Avatar picture must be JPG or PNG format!', 'error');
                        return;
                    }

                    try {
                        // ÊòæÁ§∫È¢ÑËßà
                        const reader = new FileReader();
                        reader.addEventListener('load', () => {
                            imageUrl.value = reader.result;
                        });
                        reader.readAsDataURL(file);
                        imgRaw.value = file;
                    } catch (error) {
                        console.error('Failed to process image:', error);
                        showToast('Failed to process image. Please try another image.', 'error');
                    }
                };

                // ‰øùÂ≠ò
                const save = async () => {
                    if (!hasChanges.value || loading.value) {
                        showToast('No changes to save.', 'info');
                        return;
                    }

                    loading.value = true;
                    try {
                        const values = {};

                        // Â§ÑÁêÜÂ§¥ÂÉè
                        if (imgRaw.value) {
                            const fileList = [imgRaw.value];
                            const [image] = await image2Attach(fileList);
                            values.avatar = Buffer.from(image.data, 'hex').toString('base64');
                        }

                        // Â§ÑÁêÜÁî®Êà∑Âêç
                        if (username.value !== userStore.last?.name) {
                            values.name = username.value;
                        }

                        // Â§ÑÁêÜ‰∏™‰∫∫ÁÆÄ‰ªã
                        if (profile.value !== userStore.last?.bio) {
                            values.bio = profile.value;
                        }

                        // Ëé∑Âèñ ECDH ÂÖ¨Èí•ÔºàÂ¶ÇÊûúÊ≤°ÊúâÔºâ
                        if (!userStore.last?.chatpubkey) {
                            const ecdh = await getEcdhPublickey();
                            if (ecdh) {
                                values.chatpubkey = ecdh.ecdhPubKey;
                            }
                        }

                        // Ë∞ÉÁî®ÂàõÂª∫ÊàñÊõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
                        await createOrUpdateUserInfo({
                            userData: values,
                            oldUserData: {
                                nameId: userStore.last?.nameId || '',
                                bioId: userStore.last?.bioId || '',
                                avatarId: userStore.last?.avatarId || '',
                                chatpubkey: userStore.last?.chatpubkey || '',
                            },
                            options: {
                                feeRate: 1,
                                network: 'livenet',
                                assistDomain: CONSTANTS.METASO_ASSET_API,
                            },
                        });

                        // Â¶ÇÊûúÊòØÈ¶ñÊ¨°ËÆæÁΩÆÔºåËé∑Âèñ MVC Â•ñÂä±
                        if (!userStore.last.nameId) {
                            const publicKey = await window.metaidwallet.btc.getPublicKey();
                            const signature = await window.metaidwallet.btc.signMessage('metaso.network');
                            await getMVCRewards(
                                {
                                    address: userStore.last.address,
                                    gasChain: 'mvc',
                                },
                                {
                                    'X-Public-Key': publicKey,
                                    'X-Signature': signature,
                                }
                            );
                        }

                        // Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
                        await userStore.setUserInfo(userStore.last.address);
                        showToast('Profile updated successfully!', 'success');
                        emit('update:modelValue', false);
                    } catch (error) {
                        console.error('Failed to save profile changes:', error);
                        showToast('Failed to save profile changes.', 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                const closeModal = () => {
                    if (!loading.value) {
                        emit('update:modelValue', false);
                    }
                };

                return {
                    fileInput,
                    username,
                    profile,
                    imageUrl,
                    currentAvatar,
                    loading,
                    hasChanges,
                    triggerFileInput,
                    handleFileChange,
                    save,
                    closeModal,
                };
            }
        };

        // Ë¥πÁéáÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const FeeModal = {
            props: {
                modelValue: Boolean
            },
            emits: ['update:modelValue', 'confirm'],
            template: `
                <div v-if="modelValue" class="modal modal-open">
                    <div class="modal-box w-full max-w-2xl">
                        <h3 class="font-bold text-lg mb-4">Fee Settings</h3>

                        <!-- BTC Section -->
                        <div class="mb-6">
                            <div class="flex items-center gap-2 mb-3 cursor-pointer" @click="selectChain('btc')">
                                <span class="text-2xl">‚Çø</span>
                                <div>
                                    <div class="font-semibold">BTC Network</div>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-3">
                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'economyFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('economyFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">ECO</div>
                                        <div class="text-sm">{{ chainStore.state.btc.economyFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'halfHourFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('halfHourFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Normal</div>
                                        <div class="text-sm">{{ chainStore.state.btc.halfHourFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'customizeFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('customizeFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Custom</div>
                                        <input v-if="selectedChain === 'btc' && selectedBTCFeeType === 'customizeFee'"
                                               v-model="customBTCValue"
                                               type="number"
                                               class="input input-sm w-16 text-center"
                                               @click.stop
                                               :min="1" />
                                        <div v-else class="text-sm">{{ chainStore.state.btc.customizeFee }} sat/vB</div>
                                    </div>
                                </button>
                            </div>
                        </div>

                        <!-- MVC Section -->
                        <div class="mb-6">
                            <div class="flex items-center gap-2 mb-3 cursor-pointer" @click="selectChain('mvc')">
                                <span class="text-2xl">‚ìÇ</span>
                                <div>
                                    <div class="font-semibold">MVC Network</div>
                                    <span class="badge badge-warning badge-sm">Bitcoin sidechain</span>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-3">
                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'economyFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('economyFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">ECO</div>
                                        <div class="text-sm">{{ chainStore.state.mvc.economyFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'fastestFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('fastestFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">High</div>
                                        <div class="text-sm">{{ chainStore.state.mvc.fastestFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'customizeFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('customizeFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Custom</div>
                                        <input v-if="selectedChain === 'mvc' && selectedMVCFeeType === 'customizeFee'"
                                               v-model="customMVCValue"
                                               type="number"
                                               class="input input-sm w-16 text-center"
                                               @click.stop />
                                        <div v-else class="text-sm">{{ chainStore.state.mvc.customizeFee }} sat/vB</div>
                                    </div>
                                </button>
                            </div>
                        </div>

                        <div class="modal-action">
                            <button class="btn" @click="$emit('update:modelValue', false)">Cancel</button>
                            <button class="btn btn-primary" @click="handleConfirm">OK</button>
                        </div>
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                const chainStore = useChainStore();
                const { showToast } = useToast();

                const selectedChain = ref('btc');
                const selectedBTCFeeType = ref(chainStore.state.btc.selectedFeeType);
                const selectedMVCFeeType = ref(chainStore.state.mvc.selectedFeeType);
                const customBTCValue = ref(chainStore.state.btc.customizeFee);
                const customMVCValue = ref(chainStore.state.mvc.customizeFee);

                const selectChain = (chain) => {
                    selectedChain.value = chain;
                };

                const selectFeeType = (feeType, chain) => {
                    selectedChain.value = chain;
                    if (chain === 'btc') {
                        selectedBTCFeeType.value = feeType;
                    } else {
                        selectedMVCFeeType.value = feeType;
                    }
                };

                const handleConfirm = () => {
                    chainStore.setCurrentChain(selectedChain.value);

                    if (selectedChain.value === 'btc') {
                        chainStore.setBtcFeeType(selectedBTCFeeType.value);
                        if (selectedBTCFeeType.value === 'customizeFee') {
                            if (customBTCValue.value < 1) {
                                showToast('BTC custom fee must be at least 1 sat/vB', 'error');
                                customBTCValue.value = 1;
                            }
                            chainStore.setBtcCustomizeFee(customBTCValue.value);
                        }
                    } else {
                        chainStore.setMvcFeeType(selectedMVCFeeType.value);
                        if (selectedMVCFeeType.value === 'customizeFee') {
                            chainStore.setMvcCustomizeFee(customMVCValue.value);
                        }
                    }

                    emit('update:modelValue', false);
                };

                watch(() => props.modelValue, (newValue) => {
                    if (newValue) {
                        selectedChain.value = chainStore.state.currentChain;
                        if (selectedChain.value === 'btc') {
                            selectedBTCFeeType.value = chainStore.state.btc.selectedFeeType;
                            customBTCValue.value = chainStore.state.btc.customizeFee;
                        } else {
                            selectedMVCFeeType.value = chainStore.state.mvc.selectedFeeType;
                            customMVCValue.value = chainStore.state.mvc.customizeFee;
                        }
                    }
                }, { immediate: true });

                return {
                    chainStore,
                    selectedChain,
                    selectedBTCFeeType,
                    selectedMVCFeeType,
                    customBTCValue,
                    customMVCValue,
                    selectChain,
                    selectFeeType,
                    handleConfirm
                };
            }
        };

        // ==================== Êñá‰ª∂‰∏ä‰º†ÁªÑ‰ª∂ ====================
        const FileUploader = {
            template: `
                <div class="card bg-base-100 shadow-xl">
                    <div class="card-body">
                        <h2 class="card-title">Upload Files to Chain</h2>

                        <!-- ÊãñÊãΩ‰∏ä‰º†Âå∫Âüü -->
                        <div
                            class="file-drop-zone"
                            :class="{ 'drag-over': isDragging }"
                            @drop.prevent="handleDrop"
                            @dragover.prevent="handleDragOver"
                            @dragleave.prevent="handleDragLeave"
                            @click="triggerFileInput">
                            <input
                                ref="fileInput"
                                type="file"
                                multiple
                                @change="handleFileSelect"
                                style="display: none;"
                            />
                            <div class="text-center py-8">
                                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg>
                                <p class="mt-2 text-sm text-gray-600">
                                    <span class="font-semibold text-blue-600">Click to select</span> or drag and drop files here
                                </p>
                                <p class="text-xs text-gray-500 mt-1">Support multiple files (Max 10MB per file)</p>
                            </div>
                        </div>

                        <!-- Êñá‰ª∂È¢ÑËßàÂàóË°® -->
                        <div v-if="files.length > 0" class="mt-4">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="text-sm font-semibold text-gray-700">Selected Files ({{ files.length }})</h3>
                                <button @click="clearAllFiles" class="btn btn-sm btn-ghost text-red-600">
                                    Clear All
                                </button>
                            </div>

                            <div class="file-preview-list">
                                <div
                                    v-for="(fileItem, index) in files"
                                    :key="index"
                                    class="file-preview-item">
                                    <!-- Êñá‰ª∂È¢ÑËßàÂÜÖÂÆπ -->
                                    <div class="file-preview-content">
                                        <!-- ÂõæÁâáÈ¢ÑËßà -->
                                        <img
                                            v-if="fileItem.type === 'image'"
                                            :src="fileItem.preview"
                                            :alt="fileItem.name"
                                            class="file-thumbnail"
                                        />
                                        <!-- ËßÜÈ¢ëÈ¢ÑËßà -->
                                        <video
                                            v-else-if="fileItem.type === 'video'"
                                            :src="fileItem.preview"
                                            class="file-thumbnail"
                                            controls
                                        ></video>
                                        <!-- Èü≥È¢ëÈ¢ÑËßà -->
                                        <div v-else-if="fileItem.type === 'audio'" class="file-icon-wrapper">
                                            <svg class="file-icon text-purple-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path d="M18 3a1 1 0 00-1.196-.98l-10 2A1 1 0 006 5v9.114A4.369 4.369 0 005 14c-1.657 0-3 .895-3 2s1.343 2 3 2 3-.895 3-2V7.82l8-1.6v5.894A4.37 4.37 0 0015 12c-1.657 0-3 .895-3 2s1.343 2 3 2 3-.895 3-2V3z" />
                                            </svg>
                                        </div>
                                        <!-- PDF ÂõæÊ†á -->
                                        <div v-else-if="fileItem.type === 'pdf'" class="file-icon-wrapper">
                                            <svg class="file-icon text-red-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                            </svg>
                                        </div>
                                        <!-- ZIP ÂõæÊ†á -->
                                        <div v-else-if="fileItem.type === 'archive'" class="file-icon-wrapper">
                                            <svg class="file-icon text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M4 4a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V8a2 2 0 00-2-2h-5L9 4H4zm7 5a1 1 0 10-2 0v1H8a1 1 0 100 2h1v1a1 1 0 102 0v-1h1a1 1 0 100-2h-1V9z" clip-rule="evenodd" />
                                            </svg>
                                        </div>
                                        <!-- ÂÖ∂‰ªñÊñá‰ª∂ÂõæÊ†á -->
                                        <div v-else class="file-icon-wrapper">
                                            <svg class="file-icon text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                                            </svg>
                                        </div>
                                    </div>

                                    <!-- Êñá‰ª∂‰ø°ÊÅØ -->
                                    <div class="file-info">
                                        <p class="file-name" :title="fileItem.name">{{ fileItem.name }}</p>
                                        <p class="file-meta">{{ formatFileSize(fileItem.size) }} ¬∑ {{ fileItem.file.type || 'Unknown' }}</p>
                                    </div>

                                    <!-- Âà†Èô§ÊåâÈíÆ -->
                                    <button @click="removeFile(index)" class="file-remove-btn">
                                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- ‰∏ä‰º†ÊåâÈíÆÂíåÁä∂ÊÄÅ -->
                        <div class="card-actions justify-end mt-4">
                            <button
                                v-if="files.length > 0"
                                class="btn btn-primary"
                                @click="uploadFiles"
                                :disabled="isUploading || files.length === 0">
                                <span v-if="isUploading" class="loading loading-spinner"></span>
                                {{ isUploading ? uploadProgress : 'Upload to Chain' }}
                            </button>
                        </div>

                        <!-- ‰∏ä‰º†Áä∂ÊÄÅÊèêÁ§∫ -->
                        <div v-if="uploadStatus" class="alert mt-4" :class="uploadStatusClass">
                            {{ uploadStatus }}
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const { ref, computed } = Vue;
                 const { showToast } = useToast();

                // Â∏∏ÈáèÂÆö‰πâ
                const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

                // Áä∂ÊÄÅÁÆ°ÁêÜ
                const fileInput = ref(null);
                const files = ref([]);
                const isDragging = ref(false);
                const isUploading = ref(false);
                const uploadStatus = ref('');
                const currentUploadIndex = ref(0);
                     
                // ËÆ°ÁÆóÂ±ûÊÄß
                const uploadProgress = computed(() => {
                    if (files.value.length === 0) return 'Upload to Chain';
                    return `Uploading ${currentUploadIndex.value + 1}/${files.value.length}...`;
                });

                const uploadStatusClass = computed(() => {
                    if (uploadStatus.value.includes('ÊàêÂäü') || uploadStatus.value.includes('Success')) {
                        return 'alert-success';
                    } else if (uploadStatus.value.includes('Â§±Ë¥•') || uploadStatus.value.includes('Error') || uploadStatus.value.includes('ÈîôËØØ')) {
                        return 'alert-error';
                    }
                    return 'alert-info';
                });

                // Êñá‰ª∂Á±ªÂûãÂà§Êñ≠
                const getFileType = (file) => {
                    const type = file.type;
                    if (type.startsWith('image/')) return 'image';
                    if (type.startsWith('video/')) return 'video';
                    if (type.startsWith('audio/')) return 'audio';
                    if (type === 'application/pdf') return 'pdf';
                    if (type.includes('zip') || type.includes('rar') || type.includes('7z') || type.includes('tar')) return 'archive';
                    return 'other';
                };

                // ÁîüÊàêÊñá‰ª∂È¢ÑËßà
                const generatePreview = (file, type) => {
                    return new Promise((resolve) => {
                        if (type === 'image' || type === 'video') {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        } else {
                            resolve(null);
                        }
                    });
                };

                // Ê∑ªÂä†Êñá‰ª∂Âà∞ÂàóË°®
                const addFiles = async (newFiles) => {
                    const oversizedFiles = [];
                    const validFiles = [];

                    // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
                    for (const file of newFiles) {
                        if (file.size > MAX_FILE_SIZE) {
                            oversizedFiles.push(file.name);
                        } else {
                            validFiles.push(file);
                        }
                    }

                    // ÊòæÁ§∫Ë∂ÖÂ§ßÊñá‰ª∂ÊèêÁ§∫
                    if (oversizedFiles.length > 0) {
                        const fileList = oversizedFiles.join(', ');
                        showToast(`‰ª•‰∏ãÊñá‰ª∂Ë∂ÖËøá10MBÈôêÂà∂ÔºåÂ∑≤ÂøΩÁï•: ${fileList}`, 'error');
                    }

                    // Ê∑ªÂä†ÊúâÊïàÊñá‰ª∂
                    for (const file of validFiles) {
                        const type = getFileType(file);
                        const preview = await generatePreview(file, type);
                        files.value.push({
                            file,
                            name: file.name,
                            size: file.size,
                            type,
                            preview
                        });
                    }
                };

                // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
                const triggerFileInput = () => {
                    fileInput.value?.click();
                };

                // Êñá‰ª∂ÈÄâÊã©Â§ÑÁêÜ
                const handleFileSelect = async (event) => {
                    const selectedFiles = Array.from(event.target.files || []);
                    if (selectedFiles.length > 0) {
                        await addFiles(selectedFiles);
                    }
                    // Ê∏ÖÁ©∫ input ‰ª•ÂÖÅËÆ∏ÈÄâÊã©Áõ∏ÂêåÊñá‰ª∂
                    event.target.value = '';
                };

                // ÊãñÊãΩÂ§ÑÁêÜ
                const handleDragOver = (event) => {
                    isDragging.value = true;
                };

                const handleDragLeave = (event) => {
                    isDragging.value = false;
                };

                const handleDrop = async (event) => {
                    isDragging.value = false;
                    const droppedFiles = Array.from(event.dataTransfer.files || []);
                    if (droppedFiles.length > 0) {
                        await addFiles(droppedFiles);
                    }
                };

                // ÁßªÈô§Êñá‰ª∂
                const removeFile = (index) => {
                    files.value.splice(index, 1);
                };

                // Ê∏ÖÁ©∫ÊâÄÊúâÊñá‰ª∂
                const clearAllFiles = () => {
                    files.value = [];
                    uploadStatus.value = '';
                };

                // Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
                const formatFileSize = (bytes) => {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
                };

                // ‰∏ä‰º†Êñá‰ª∂
                const uploadFiles = async () => {
                    if (files.value.length === 0) return;

                    try {
                        isUploading.value = true;
                        const results = [];

                        for (let i = 0; i < files.value.length; i++) {
                            currentUploadIndex.value = i;
                            const fileItem = files.value[i];
                            uploadStatus.value = `Ê≠£Âú®‰∏ä‰º†Êñá‰ª∂ ${i + 1}/${files.value.length}: ${fileItem.name}...`;

                            try {
                                const result = await uploadFileToChainDirect(fileItem.file);
                                results.push({
                                    name: fileItem.name,
                                    success: true,
                                    txId: result?.txId || result
                                });
                            } catch (error) {
                                console.error(`Upload failed for ${fileItem.name}:`, error);
                                results.push({
                                    name: fileItem.name,
                                    success: false,
                                    error: error.message
                                });
                            }
                        }

                        // ÊòæÁ§∫‰∏ä‰º†ÁªìÊûú
                        const successCount = results.filter(r => r.success).length;
                        const failCount = results.length - successCount;

                        if (failCount === 0) {
                            uploadStatus.value = `ÊâÄÊúâÊñá‰ª∂‰∏ä‰º†ÊàêÂäü! (${successCount}/${results.length})`;
                            showToast('ÊâÄÊúâÊñá‰ª∂‰∏ä‰º†ÊàêÂäü', 'success');
                            // ‰∏ä‰º†ÊàêÂäüÂêéÊ∏ÖÁ©∫Êñá‰ª∂ÂàóË°®
                            setTimeout(() => {
                                clearAllFiles();
                            }, 2000);
                        } else {
                            uploadStatus.value = `ÈÉ®ÂàÜÊñá‰ª∂‰∏ä‰º†Â§±Ë¥•: ÊàêÂäü ${successCount}, Â§±Ë¥• ${failCount}`;
                            showToast(`ÈÉ®ÂàÜÊñá‰ª∂‰∏ä‰º†Â§±Ë¥•: ÊàêÂäü ${successCount}, Â§±Ë¥• ${failCount}`, 'warning');
                        }
                        return results.map(r => r.txId || r.error);
                    } catch (error) {
                        console.error('Upload error:', error);
                        uploadStatus.value = `‰∏ä‰º†Â§±Ë¥•: ${error.message}`;
                        showToast(`‰∏ä‰º†Â§±Ë¥•: ${error.message}`, 'error');
                    } finally {
                        isUploading.value = false;
                        currentUploadIndex.value = 0;
                    }
                };

                return {
                    fileInput,
                    files,
                    isDragging,
                    isUploading,
                    uploadStatus,
                    uploadProgress,
                    uploadStatusClass,
                    triggerFileInput,
                    handleFileSelect,
                    handleDragOver,
                    handleDragLeave,
                    handleDrop,
                    removeFile,
                    clearAllFiles,
                    formatFileSize,
                    uploadFiles
                };
            }
        };

        // Áî®Êà∑Êìç‰ΩúÁªÑ‰ª∂
        const LoginUserOperate = {
            components: {
                UserAvatar,
                FeeModal
            },
            template: `
                <div class="flex items-center gap-3">
                    <!-- ËøûÊé•Èí±ÂåÖÊåâÈíÆ -->
                    <button v-if="!connectionStore.connected"
                            class="btn btn-primary"
                            @click="openConnectionModal">
                        Connect Wallet
                    </button>

                    <!-- ÊéàÊùÉÊåâÈíÆ -->
                    <button v-else-if="!credentialsStore.get"
                            class="btn btn-primary"
                            @click="credentialsStore.login()">
                        Authorize
                    </button>

                    <!-- Áî®Êà∑‰ø°ÊÅØ -->
                    <template v-else-if="userStore.isAuthorized">
                        <UserAvatar
                            :image="userStore.last.avatar"
                            :meta-id="userStore.last.metaid"
                            :name="userStore.last.name" />

                        <!-- Áî®Êà∑Âêç -->
                        <span class="font-medium">{{ userStore.last.name || 'Anonymous' }}</span>
                    </template>

                    <!-- Êõ¥Â§öÊìç‰ΩúËèúÂçï -->
                    <div class="dropdown dropdown-end" v-if="userStore.isAuthorized">
                        <label tabindex="0" class="btn btn-circle btn-ghost">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="w-5 h-5 stroke-current">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
                            </svg>
                        </label>
                        <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-64 mt-3 z-[9999]">
                            <!-- Fee Settings -->
                            <li>
                                <a @click="handleFeeClick" class="!flex !flex-row items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <span>{{ chainStore.state.currentChain.toUpperCase() }}</span>
                                        <span class="font-medium">{{ currentFeeRate }}</span>
                                        <span class="text-sm text-gray-500">
                                            {{ chainStore.state.currentChain === 'btc' ? 'sat/vB' : 'sats/b' }}
                                        </span>
                                    </div>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                    </svg>
                                </a>
                            </li>

                            <div class="divider my-0"></div>

                            <!-- Logout -->
                            <li>
                                <a @click="connectionStore.disconnect()" class="!text-red-500 !flex !flex-row items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                    </svg>
                                    <span class='ml-2'>Logout</span>
                                </a>
                            </li>
                        </ul>
                    </div>

                    <!-- Fee Modal -->
                    <FeeModal v-model="showFeeModal" @confirm="handleFeeConfirm" />
                </div>
            `,
            setup() {
                const { openConnectionModal } = useConnectionModal();
                const connectionStore = useConnectionStore();
                const credentialsStore = useCredentialsStore();
                const userStore = useUserStore();
                const chainStore = useChainStore();

                const showFeeModal = ref(false);

                const currentFeeRate = computed(() => {
                    const currentChain = chainStore.state.currentChain;
                    const chainData = chainStore.state[currentChain];
                    const selectedFeeType = chainData.selectedFeeType;
                    return chainData[selectedFeeType];
                });

                const handleFeeClick = () => {
                    showFeeModal.value = true;
                };

                const handleFeeConfirm = (data) => {
                    console.log('Fee configuration updated:', data);
                };

                return {
                    openConnectionModal,
                    connectionStore,
                    credentialsStore,
                    userStore,
                    chainStore,
                    showFeeModal,
                    currentFeeRate,
                    handleFeeClick,
                    handleFeeConfirm
                };
            }
        };

        // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂
        const App = {
            components: {
                ConnectWalletModal,
                LoginUserOperate,
                ToastContainer,
                ProfileEditModal,
                FileUploader
            },
            template: `
                <div class="min-h-screen bg-base-200">
                    <!-- Toast Container -->
                    <ToastContainer />

                    <!-- È°∂ÈÉ®ÂØºËà™Ê†è -->
                    <div class="navbar bg-base-100 shadow-lg">
                        <div class="flex-1">
                           
                        </div>
                        <div class="flex-none">
                            <LoginUserOperate />
                        </div>
                    </div>

                    <!-- ‰∏ªÂÜÖÂÆπÂå∫Âüü -->
                    <div class="container mx-auto p-8">
                        <!-- Êñá‰ª∂‰∏ä‰º†ÁªÑ‰ª∂ -->
                        <FileUploader />
                    </div>

                    <!-- ËøûÊé•Èí±ÂåÖÊ®°ÊÄÅÊ°Ü -->
                    <ConnectWalletModal />

                    <!-- Áî®Êà∑ËµÑÊñôÁºñËæëÊ®°ÊÄÅÊ°Ü -->
                    <ProfileEditModal v-model="layoutStore.isShowProfileEditModal" />
                </div>
            `,
            setup() {
                const rootStore = useRootStore();
                const layoutStore = useLayoutStore();
                const connectionStore = useConnectionStore();
                const userStore = useUserStore();
                const credentialsStore = useCredentialsStore();
                const chainStore = useChainStore();
                const { showToast } = useToast();
                const { closeConnectionModal } = useConnectionModal();

                const accountInterval = ref(null);

                // ËøûÊé•MetaletÈí±ÂåÖ
                async function connectMetalet() {
                    try {
                        const connection = await connectionStore.connect('metalet');
                        if (connection?.status === 'connected') {
                            await credentialsStore.login();
                        }
                    } catch (error) {
                        showToast(error.message, 'error');
                    }
                }

                // Â§ÑÁêÜÁΩëÁªúÂèòÊõ¥
                function handleNetworkChanged(network) {
                    const networkStore = useNetworkStore();
                    const appNetwork = networkStore.network;
                    if (network !== appNetwork) {
                        connectionStore.disconnect();
                    }
                }

                // MetaletË¥¶Êà∑ÂèòÊõ¥Â§ÑÁêÜ
                const metaletAccountsChangedHandler = () => {
                    try {
                        if (connectionStore.last.wallet !== 'metalet') return;
                        if (rootStore.isWebView) return;
                        connectionStore.disconnect();
                        showToast('Metalet Ë¥¶Êà∑Â∑≤ÂèòÊõ¥„ÄÇÊ≠£Âú®Âà∑Êñ∞È°µÈù¢...', 'warning');
                        sleep().then(() => completeReload());
                    } catch (error) {
                        console.error('Error in metaletAccountsChangedHandler:', error);
                    }
                };

                // MetaletÁΩëÁªúÂèòÊõ¥Â§ÑÁêÜ
                const metaletNetworkChangedHandler = (network) => {
                    if (connectionStore.last.wallet !== 'metalet') return;
                    if (rootStore.isWebView) return;
                    handleNetworkChanged(network);
                };

                // AppÁôªÂΩïÊàêÂäüÂ§ÑÁêÜ
                const appLoginSuccessHandler = async (data) => {
                    try {
                        if (!userStore.isAuthorized) {
                            await connectMetalet();
                        }
                    } catch (error) {
                        showToast(error, 'error');
                    }
                };

                // AppË¥¶Êà∑ÂàáÊç¢Â§ÑÁêÜ
                const appAccountSwitchHandler = async (data) => {
                    try {
                        if (rootStore.isWebView) {
                            await connectionStore.disconnect();
                            await connectMetalet();
                        }
                    } catch (error) {
                        throw new Error(error);
                    }
                };

                // AppÁôªÂá∫Â§ÑÁêÜ
                const appLogoutHandler = async (data) => {
                    try {
                        console.log("ÈÄÄÂá∫ÁôªÂΩïÊàêÂäü", data);
                        if (userStore.isAuthorized) {
                            await connectionStore.disconnect();
                            closeConnectionModal();
                        }
                    } catch (error) {
                        console.error('Error in Logout handler:', error);
                    }
                };

                onMounted(async () => {
                    // Á≠âÂæÖ MetaIDJs Âä†ËΩΩÂÆåÊàê
                    await waitForMetaIDJs();
                    console.log('MetaIDJs loaded:', MetaIDJs);
                    console.log('TxComposer:', TxComposer);
                    console.log('mvc:', mvc);

                    // ÂàùÂßãÂåñË¥πÁéá
                    await chainStore.updateAllFeeRates();

                    // ÂÆöÊó∂Ê£ÄÊü•Ë¥¶Êà∑Áä∂ÊÄÅ
                    accountInterval.value = setInterval(async () => {
                        try {
                            rootStore.checkWebViewBridge();
                            if (rootStore.isWebView) return;

                            if (!userStore.isAuthorized) {
                                if (rootStore.isWebView) {
                                    await connectMetalet();
                                }
                            }

                            if (window.metaidwallet && connectionStore.last.status === 'connected' && userStore.isAuthorized) {
                                const res = await window.metaidwallet.getAddress();
                                if (res?.status === 'not-connected' || userStore.last?.address !== res) {
                                    connectionStore.disconnect();
                                    showToast('Metalet Ë¥¶Êà∑Â∑≤ÂèòÊõ¥', 'warning');
                                }
                            }
                        } catch (error) {
                            console.error('Error checking account status:', error);
                        }
                    }, 2000);

                    // ËÆæÁΩÆMetalet‰∫ã‰ª∂ÁõëÂê¨
                    const checkMetalet = () => {
                        rootStore.checkWebViewBridge();
                        if (window.metaidwallet) {
                            try {
                                window.metaidwallet?.on?.('accountsChanged', metaletAccountsChangedHandler);
                                window.metaidwallet?.on?.('networkChanged', metaletNetworkChangedHandler);
                                window.metaidwallet?.on?.('LoginSuccess', appLoginSuccessHandler);
                                window.metaidwallet?.on?.('onAccountSwitch', appAccountSwitchHandler);
                                window.metaidwallet?.on?.('Logout', appLogoutHandler);
                            } catch (err) {
                                console.error('Failed to setup Metalet listeners:', err);
                            }
                        } else {
                            setTimeout(checkMetalet, 100);
                        }
                    };

                    checkMetalet();

                    // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄ‰∏ÄËá¥ÊÄß
                    if (window.metaidwallet && connectionStore.last.status === 'connected' && userStore.isAuthorized) {
                        rootStore.checkBtcAddressSameAsMvc()
                            .catch(() => {
                                showToast('Metalet BTCÂΩìÂâçÂú∞ÂùÄ‰∏éMVCÂú∞ÂùÄ‰∏ç‰∏ÄËá¥ÔºåËØ∑ÂàáÊç¢BTCÂú∞ÂùÄ‰∏éMVCÂú∞ÂùÄ‰∏ÄËá¥ÂêéÂÜçËøõË°å‰ΩøÁî®', 'warning');
                                setTimeout(() => {
                                    connectionStore.disconnect();
                                }, 3000);
                            });
                    }
                });

                onUnmounted(() => {
                    if (accountInterval.value) {
                        clearInterval(accountInterval.value);
                    }

                    // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨
                    try {
                        window.metaidwallet?.removeListener?.('accountsChanged', metaletAccountsChangedHandler);
                        window.metaidwallet?.removeListener?.('networkChanged', metaletNetworkChangedHandler);
                        window.metaidwallet?.removeListener?.('LoginSuccess', appLoginSuccessHandler);
                        window.metaidwallet?.removeListener?.('Logout', appLogoutHandler);
                        window.metaidwallet?.removeListener?.('onAccountSwitch', appAccountSwitchHandler);
                    } catch (error) {
                        console.error('Error removing event listeners:', error);
                    }
                });

                return {
                    userStore,
                    connectionStore,
                    layoutStore
                };
            }
        };

        // ==================== ÂàùÂßãÂåñÂ∫îÁî® ====================
        const pinia = createPinia();
        const app = createApp(App);
        app.use(pinia);
        app.mount('#app');
    </script>
</body>
</html>
